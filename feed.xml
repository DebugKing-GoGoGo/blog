<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>pezy's blog</title>
    <link href="feed.xml" rel="self" />
    <link href="" />
    <id>feed.xml</id>
    <entry>
        <title type="html"><![CDATA[生活的意义]]></title>
        <link href="life/thinking-in-life"/>
        <published>2014-03-27T03:23:00.000Z</published>
        <updated>2014-03-27T03:23:00.000Z</updated>
        <id>life/thinking-in-life</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>大概是几天前，Jian对我说，不知道生活到底有什么意义。那时的我们走在空旷的大街上，正准备去电影院去看刚上映的《白日焰火》。</p>
<p>我当时心里却充满着意义。天天加班的乏味生活，能够抽出空来看场电影，多么有意义！如果恰碰上一场好电影，那真是生活的恩赐了。当然，我只是心里想想，如果说出来，又要遭到Jian的鄙视了。</p>
<p>今天回家，跟爸妈汇报完最近的工作窘境，反而有点失落落的。这样的工作，这样的环境，与我刚毕业时的理想相差万里，但在这不长不短的三年间，我也渐渐明白了自己所处的位置。这个世界太大，不能想当然，有太多我没见过的山，有太多我没见过的海。渺天地之一粟，毫不夸张。</p>
<p>生活的意义在我这里最终是归于荒诞的。一切都是那么合情合理，那么无懈可击。你想随口抱怨，却会在随后的深思中发现完全不应该。怨不了天，由不得人。世间万物自然生长，而偶尔交错的枝桠，却是那么的荒诞。</p>
<p>也许只是求而不得的骚动呢？人们往往是求A的时候得到了B，一拨人暗骂了一句，扔了B，继续寻求A；另一拨人觉得B也不赖，便如世事洞明般的说一句：得不到的不强求。而最幸运的那一拨，终于得到了A，若干年之后，发现A也不是自己想要的，于是蹉跎一世，悔不当初。</p>
<p>到头来，所有人都是悲剧，整个人类史就是一场悲剧的迁徙。人往往会花上一辈子去想明白自己要的到底是什么，可是时间往往饱含最大的恶意，用匆匆几年春秋，嗤笑着人类的可笑。想想就觉得荒诞。</p>
<p>我觉得生活真正的意义，都曾在我们每一个人心里暂留。只是它太过匆匆，给我们留下了完全不同的印象。我们都以为那才是真的，其实呢。</p>
<p>没有意义，也许才是最大的意义。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[采集器设计思考]]></title>
        <link href="work/thinking-of-das"/>
        <published>2013-11-10T00:00:00.000Z</published>
        <updated>2013-11-10T00:00:00.000Z</updated>
        <id>work/thinking-of-das</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>领导总是想一出是一出，C#的移植工作才刚刚走上正轨，便把我们叫停，还是让我们把精力放到采集模块的设计上去。</p>
<p>自我入职以来，我便一直从事着与采集相关的工作。开始我觉得这东西很神秘，很底层，可以有机会破解各类数据文件。后来渐渐觉得这是个无比简单的活计，也不会被领导重视。再后来多次重构采集框架，让我意识到，挑战无处不在。</p>
<p>采集是个什么样的概念呢？就我的工作而言，其业务场景一直局限于井场仪器实时数据的截取。钻井过程中，综合录井仪的传感器，会将各种特征参数的值测量出来，在经过一些简单的计算，形成一套实时变化的数据，因仪器类型的不同，可能会存储于本地数据库中，可能只是暂存于临时文件，更先进些的会组织成<a href="http://home.sprynet.com/~carob/index.htm">WITS</a>标准的格式，发送到总部服务器进行存储。这些实时数据，被研究的价值并不大，传回总部服务器后，也多数被绘制成实时曲线进行展示。仅此而已，也许出现井喷等事故时，可以将曲线回放，分析事故原因。</p>
<p>那么由此可见，采集的重点，其一在于真实性，其二在于时效性。这有点像是新闻了。保障真实性，就是数据不能被人为修正，传感器测量或计算的值应该原封不动地被传回；保障时效性，就是传感器刚一产生数据，就要被马上截取，并传回总部，期间时差不能超过5秒。所以，在设计采集程序的时候，第一要务是找到哪一个数据表、数据文件、数据包是&quot;原生态&quot;的，第二就是如何最小的减小开销，极大程度的减少时间消耗。功力就在两个词：观察、高效。</p>
<p>遇到没有见过的仪器，首先就是要分析该仪器是如何处理数据的，最好能拿到它配套的计算软件，检查每一个有可能&quot;藏污纳垢&quot;的位置，快速定位应该取哪里的数据。然后就是考虑算法，如果是文件，如何能最快定位到新数据产生的位置，截取需要的值；如果是数据表，如何能优化SQL查询语句，如避免使用order by等费时的命令。</p>
<p>以上基本是我第一年努力的目标。毕竟现场条件艰苦，不宜久留，快速找到自己需要的东西是最基本的能力。</p>
<p>这个层面仍然属于业务范畴，真正落实到Code，就不得不未雨绸缪了。你想，如果遇到一个你完全不知道结构的二进制文件，让你快速解析出所需的数据，需要多长时间？如果遇到你不熟悉的数据库，让你从中获取数据，你又需要多长时间？</p>
<p>这就需要提前积累，如必须设计一个公共的类，所有对于数据库的增删改查都应该封装成一个统一的接口，无论你面对的是SQL Server、Access、Foxpro、MySQL、Firebird还是SQLite，都执行相同的方法，那么取数据库特定表的数据，不就变得易如反掌。文件也是一样，文件的组织结构无非以下两类：</p>
<ol>
<li>一个文件一条数据<ul>
<li>Key/Value形式</li>
<li>结构体组织</li>
</ul>
</li>
<li>一个文件全部数据<ul>
<li>Table形式，有表头，然后一行一行数据</li>
<li>结构体组织</li>
</ul>
</li>
</ol>
<p>结构体组织多为二进制，Key/Value和Table形式多为明文文本。前者解析的重点是结构体，后者解析的重点是表头。其余的操作是否也可以封装为公共类？这样我拿到结构体或表头，便能够立刻解析出最新数据。</p>
<p>如果是较先进的仪器，符合WITS标准，并具备WITS发送能力，那么是否也应该准备好网络接收的类，无论是TCP Server还是Client，UDP，串口还是工业级别的OPC、DataSocket，我仍旧可以调用同样的方法。这样封装之后，我随时可以配置自己的接收端，接收到需要的数据。接收到了数据，是WITS格式的，还需要解析，这个操作也是需要封装的。</p>
<p>好了，需要储备的技术还真不少，数据库、文件、网络、串口、各种协议。这些都是公共基础子模块，是必须不断优化的。这些代码的优劣是采集程序质量的决定因素。</p>
<p>这就是我第二年的目标，准确的说，其实没有做的很好，期间也后悔过多次在大学没有夯实基础。没有几手硬功夫。</p>
<p>其实到此为止，核心的东西我们都设计地差不多了，最后也是最难设计的，便是交互界面。还好在能源行业，对于用户体验并不是互联网那套思路，井场的工人们，也没有时间无聊到观察界面是否优雅。界面的目的就是最快最直接的呈现软件具备的功能。让现场人员，可以按最少的按钮，输入最少的信息，以最快的速度完成一次操作。(互联网正好相反，设计人员更希望用户多花点时间在使用软件上，最好流连忘返，忘了吃饭)</p>
<p>第三年我基本在参考国外程序的类似程序，我发现国外的软件最为突出的特点就是灵活。他们的代码里一定没有任何写死的硬编码，每一个可能改变的地方，都会留出配置接口。但这样的缺陷也是明显的，配置界面会非常的复杂，然后后台数据库设计的非常的复杂，所有表、字段都是灵活的，都有元数据字典来管理。这就是老外的舍取:</p>
<p>他们选择了<strong>七十二变</strong>，放弃了<strong>傻瓜易用</strong>。他们的软件定位在给专业的人用，无形中也提高了他们软件的品味。</p>
<p>品味，是一个很玄妙的词，乔布斯有他的品味，苹果才如此优雅，你根本不需要学。但盖茨难道没有他的品味么？Windows难用的恰好合适，刚好让你能学会，还颇有成就感。再看看Linus呢？他的品味独具特色，Linux超级难学，人家压根就没准备给小白用，那是黑客与天才的系统，他们需要工具，而非玩具。</p>
<p>回到采集，我需要做的事情，也就是找准软件的定位，然后恰如其分的给出软件应有的长相。这里面的主角依旧是配置，是不是也做到了每一个细节都能被配置？要知道井场除了综合录井仪，还有LWD/MWD，钻参仪等等，难道每一类仪器都需要重写一套采集程序么？如何拯救他们？是不是该考虑一下WITS统一的标准带来的好处呢？</p>
<p>好的软件，是一个顺畅的数据流，采集软件，更像是诗经的开篇: </p>
<blockquote>
<p>参差荇菜，左右采之。</p>
</blockquote>
<p>WITS标准就像我们的箩筐，荇菜便是数据，软件就是这条美丽的河。</p>
<p>&lt;- 全文完 -&gt;</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[噩梦]]></title>
        <link href="life/nightmare"/>
        <published>2013-07-17T00:00:00.000Z</published>
        <updated>2013-07-17T00:00:00.000Z</updated>
        <id>life/nightmare</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>今天中午睡的很沉，做了一个很长的噩梦。起来之后，浑浑噩噩，不知所以，思绪繁杂，喜忧参半。</p>
<!-- more -->

<p>从上周六到昨天，一直奔波在大西北广袤的土地上。看了许多美景，也发生了许多事情。其实我是带着很多不情愿出发的，我就想回北京，不想在这里多呆了。可是师傅强烈的意志把我说服，带着些无奈，毫无准备的上路。</p>
<p>其实这半年来的工作让我很失落，重构过多次的采集器，也陷入鸡肋的境地，那些代码曾经是那么的有活力，但我深知，这个软件彻底死了，我的努力还是多余的。我反反复复大规模重构了有两遍多，第三遍还在继续，可是我真的不想再这样认真的继续了，想过很多次，要不草草收尾吧，再去做新项目，再去慢慢吸取教训。但我心里又有点不舍，没有人看到这里面的心血，正如没有人觉得这东西有什么价值一样。</p>
<p>这次出差快一个月了，钱花的差不多，人也快得罪的差不多，我一直想卖力的干点实事，实在不行，我每天都去上井？可是我真的不愿意浪费那时间，这算不算眼高手低呢？实际上，时间还是被浪费了，那些浅尝辄止的尝试完全没有一点意义。跟着IceSoul学了挺多皮毛，有过很多次兴奋，了解了很多不曾接触的领域。明白了自己的浅薄和渺小。无论是做人做事，还是专业与性格，都与别人有太多的差距。还记得去年写的<a href="./end-of-2012">年终总结</a>么。也许那就是我的硬伤吧，想做的完美，却又缺乏见识与阅历。最终就是做了许多无用功。</p>
<p>IceSoul说的很对，我心太浮躁了。每个问题都很难深究而后形成自己的看法，往往都是人云亦云，或是故弄玄虚。枉我还是正经的计算机专业出身，很多时候都表现得太不专业。技术上又容易固步自封，缺乏深入的思考。再就是喜新厌旧，容易三天打鱼两天晒网，各种秒射。要不是工作的原因，我想我很难能在C++上有什么发展，一定也是玩玩就扔掉了。他说我像个小孩子一样，是一种幼稚，这也许不无道理。</p>
<p>可能是漏了底，其实我来这边，是很想要出点力帮点忙的，可是渐渐发现IceSoul基本上都自己搞定了，反倒是我从他那里学到了挺多，他估计对我也不太信任了，知道我能干什么不能干什么。走的太近就会有这样的危机，这就算是代价了。我忙乎来忙乎去，还不如把自己的事情干好，回北京老老实实的生活。</p>
<p>可是回去就能老实生活么，公司就要搬到昌平，难道让我去租房？我真的要想办法调换部门了么？还是直接投投简历，换份工作？更头疼的是要怎么准备结婚事宜呢？我现在有什么基础，又有什么资本呢。想到这些，就很难无忧无虑。加上父母一直催促出国或是考研，更是火上浇油，压力山大。</p>
<p>小王说得对，有能力的人早就离开了。师傅说得对，在这里基本学不到什么东西，不如小公司，不如油田应用技术部。IceSoul最早也说得对，现场的工作不难做，要看谁做。</p>
<p>以上三位都是我的师父，从小王那里学习与人打交道的能力，处世避免显得过于生硬。从师傅那里学着如何做专业软件，避免走太多弯路。从IceSoul那里学如何处理工作，如何具备清晰的思路，敏锐的了解每一个人，做到知人善任。</p>
<p>这三位师父在软件开发里，对应的就是如何做需求、如何做开发和如何做管理。每一个步骤都需要具备他们身上的特质，才可以做的完满。可这三样，一样也不适合我。</p>
<p>当我不知道如何与人打交道，如何游刃有余的混迹社会的时候，我就安慰自己，做好开发就好了。当我走过一个又一个弯路，做得东西得不到别人认可的时候，我就安慰自己，可能我具备的是综合素质，对整体项目能够进行把控。当我看到IceSoul是怎么处理现场的各种情况，各种人的时候，我只好安慰自己，年纪还小，唯有多努力。</p>
<p>这一个月虽然在工作上做得并不多，但更加看清了自己，无论是感情、还是事业上，都算一个警醒，或许以后，知道该如何为人处世，如何形成自己的风格了。</p>
<p>我想，总会有自己适合的不是？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[终是分离]]></title>
        <link href="life/last-sentence"/>
        <published>2013-07-09T00:00:00.000Z</published>
        <updated>2013-07-09T00:00:00.000Z</updated>
        <id>life/last-sentence</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>她反复说我要挂了的时候，我的脑海里是一幅幅画面。夜里走在广平大街上的、满头冒汗去机场的、心有忐忐地前往宝鸡的、一起骑车在杭州街头的。那些画面感觉黏在心头、混在血液里，生拉硬拽了一番。很难扯动。</p>
<p>好不容易扯开了一层皮，就有点像冷水过了一遍久未冲洗的褶皱一样，空空如也的缝隙里冷空气肆意流窜着。空着冷，也是抽着疼。就像通常脱了皮，起开一个口子，就想忍痛整个扯掉。让新生的皮慢慢与空气交融，慢慢生长。</p>
<p>来了三封短信。语气开始变得客气，里面似乎又带着些嘲讽，又有着点委屈和无奈。很夜了，最近都不知道什么是夜。是的，没有她我也会熬夜，我也会照样浪费时间，我也会一次一次的去西北。好像没一点区别。</p>
<p>说无悔，但其实总是带着些将就的。有些事情发生，我是很敏锐的，但我始终让自己保持迟钝，我记得&lt;离婚进行时&gt;里讲的那句，感情是讲不了道理的。于是我就退，能退就退，放弃自己的立场、习惯、甚至是尊严。做了很多我以前根本做不到的事情。我觉得时间是最强的武器，只要挨上个两三年，互相熟络了，离不开了，就磨平了互相的棱角，抱在一起不会痛了。可是，终究敌不过无缘。</p>
<p>这次栽的不轻，吃了很多亏，也真的明白了很多。债永远还不轻，太沉重了，这个尴尬的年纪，又是这样的事情。真的不想再爬起来了。小心使得万年船，人的事情，来不得一刻的放松。可是，我们的初衷是什么？不就是放松和快乐么。随心所欲不逾矩，孔子都需古稀才能做到，二十出头的年纪，又如何能驾驭得了。</p>
<p>感觉突然回到了几年前大学的日子，那种怎么努力也得不到自己想要的窘境。最后总会感慨，还是不够努力，总有那么些情况，让你的努力还不够。这是人性的束缚，也是年轻的代价。终是命运的折磨。</p>
<p>还是孤独点好，再多痛苦折磨只是自己承受，不干别人的事情。可感情处理的不好，也许是两个人终身的代价。再次说明了不能没有底线，任何情况都是这样，触碰了底线不能手软，否则付出的将是几倍于此的代价。</p>
<p>我已经在这个世界上存在了8535天，至此，没有一件真正值得骄傲的事情值得说道。太多的遗憾已经淹没了我的神经。如果再来一个8535天，会不会有不同？不知道，但能确定的是，那时已经无法回头。</p>
<p>只差40天而已。数字让人心痛。但无法回头了，彼此都无法接受了。</p>
<p>18岁之后，以为想怎么样就怎么样，不假思索，随性挥斥着时间与决定。连续碰壁，头破血流，收获的，竟然只是16、7岁年华在某本书上看到的一句话而已。这些话还会穿插在生命中出现，以前把它们当故事听了，现在才知道，原来自己也会有故事，终有一天，也会成为故事的主人公。他们承受的痛苦与折磨，自己只会感受的更真切。</p>
<p>此刻的靖边小县，窗外雨水滴答滴答的下，深夜里听得格外不是滋味。</p>
<p>17岁我听过这样的雨、20岁也听过，今年23岁，又在听这样的雨。</p>
<p>写到这里，她来了一个电话，口气缓和了许多。我竟又有些心软了，能不能就这样算了，过去吧。这让我想起，中午师傅说，在这公司把人待废了，如果我在小公司，水平肯定不会是现在这样子。我何尝不想跳巢，可是我想着，要不再待待看吧。又让我想起，老爸晚上给我电话，问对未来有没有什么考虑，研究生还有没有想法。我不是没想法，可是得过且过吧。毕竟我又不是活不下去了。</p>
<p>就像沸水青蛙，如果不是突然把它烫着，它完全不知道会如何死去。</p>
<p>感情、工作、和生活，都是需要决定的。否则，就只好等死吧。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[花一些时间思考]]></title>
        <link href="life/take-a-moment"/>
        <published>2013-07-05T00:00:00.000Z</published>
        <updated>2013-07-05T00:00:00.000Z</updated>
        <id>life/take-a-moment</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>今天小王赶到靖边，他是个好事之人，便邀这边的同事一起去搓一顿。我恰好也在，便一起同往。</p>
<p>酒桌，向来是我最厌恶的地方之一。烟雾缭绕，红着脸吹牛，顿感生命的无聊。我是个怪性子，到了这种气氛下，便警觉的很，不容丝毫轻松，拘束地不愿说一句话。我坚持滴酒不沾，所以容易冷场，明知道不太好，但也奈何不了自己。解决方法就是不去这样的场合，既然去了，就得承受尴尬。</p>
<p>酒足饭饱之后，重新坐在电脑前。突然思考了很多。也许是回忆了一天内和女友的对话，也许是瞥见了本科同学的硕士生证书，也许是看到了小王，想起了去年的自己。反正，褪去了轻浮的兴奋，放松的傻笑。一个人呆坐着，想花一些时间思考。</p>
<p>好久都没有更新这个博客了。这个既最下功夫，又花钱买了域名的博客，反而没有新浪博客更新的勤快。很忙吗？这是她经常问的一句话。这倒是一个最自慰的借口。</p>
<p>看过我以前博客的人，都能感觉到那种硬撑着的正能量，或是自我哀怨的小调子。我还经常自诩文人，其实是给自己贴金，给文人丢人。唉，越来越没自信了。</p>
<p>我想到了过去，想到了未来，昨天中午迷迷糊糊做的那个难受的梦，还横桓在我心坎里。这也许都是酒桌这样一盆冷水把我激醒的。戳中了软肋，才会另寻生路；言中了痛处，才会奋起直追。我不爱去同学聚会，不爱参加各类活动，就是怕自己的弱点暴漏在众人下，被无形的气氛逼得抱头鼠窜。</p>
<p>所以我容易沉迷在自己的世界里，玩一些小技术，学一些小知识。对那些未知领域尤其着迷，因为这里我即使受挫，只需要一点耐心，花些时间，就能获得莫大的成就感。这种感觉是容易上瘾的，有时以为找回了自我，其实是迷失而已。</p>
<p>我相信，人与人的差距并不是因为社会地位、家庭背景、成长历程等等我们习以为常的原因，而是思维观念。也许另一个世界里的我，就不会有这许多思考，依旧安于做一个小屌丝，依赖着可怜的成就感为生。也许又一个世界里的我，会彻底转变观念，直面自己的弱点，在各类场合表现出成熟的风范，能够不那么自私，能够让身边的人舒服。</p>
<p>可是这个世界的我，依旧难以摆脱根深蒂固的观念。这便是一种科学的宿命。少有人可以躲得开。</p>
<p>很多人说，你为什么就不表现出“好”的那些行为？</p>
<p>因为你懒，因为你自私，因为你娇生惯养，因为你意志薄弱。</p>
<p>我听着这许多话，继续自怨自艾着，想做点什么摆脱这样声音的围剿，想成为那个“好”的我。我对不起身边的人，我活着的方式，以为会给你们带来快乐，实际却是让你们莫名的痛苦。我不断的给这些人道歉，到最后也不好意思道歉了。也许我应该做的，只是躲入自己的森林，老死不相往来。</p>
<p>我经常那么想，这样想下去，不知道还会有怎样的心态。</p>
<p>而，正是这些脑子里装的，最底层的东西，观念和心态，决定了你是怎样的人。</p>
<p>如，我这样的，永远只能写出自怨自艾的文字，恬不知耻的拌着可怜。</p>
<p>这是精神上的乞丐，没有自己的东西，还会被人认为是自私的家伙。</p>
<p>哎，自己的事情，写在自己的博客里，谁也别看。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[有多少虚伪的了解]]></title>
        <link href="essay/shesaid"/>
        <published>2013-06-30T00:00:00.000Z</published>
        <updated>2013-06-30T00:00:00.000Z</updated>
        <id>essay/shesaid</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>有多少虚伪的了解，能让你牵肠挂肚。</p>
<p>有多少虚伪的了解，能让你无法释怀。</p>
<p>他虚伪地认同了他的虚伪，你失落地消化着你的失落。</p>
<p>有多少虚伪的了解，能让你光阴虚度。</p>
<p>有多少虚伪的了解，能让你自我满足。</p>
<p>他诚恳的保持了沉默，你独在深夜局促。</p>
<p>有多少虚伪的了解，能让你脱口而出。</p>
<p>有多少虚伪的了解，能让你不去琢磨。</p>
<p>他说那都是兴之所至，你说那不过是形式。</p>
<p>有多少虚伪的了解，能让你形同陌路。</p>
<p>有多少虚伪的了解，能让你抱头痛哭。</p>
<p>他不解为何统统都有恶意的标签，你说无知本身便是最大的恶念。</p>
<p>有多少虚伪的了解，现实在这边，爱在那边。</p>
<p>心意是否离别？爱是否无解？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[也说青瓦阁楼]]></title>
        <link href="essay/qwgl"/>
        <published>2013-05-10T00:00:00.000Z</published>
        <updated>2013-05-10T00:00:00.000Z</updated>
        <id>essay/qwgl</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>请先看看<a href="http://xn--xwq36n0ppci8b.cn/content/loft">这里</a>。</p>
<p>青瓦阁楼是一个意象，那里的瓦不是青的，说阁楼也有些小气，那是完整的一层楼。我最迷恋的顶楼。</p>
<p>但青瓦阁楼也是一间房，是主人起的名字，飘逸秀气，Jian很喜欢，那真是一间阁楼，很小，但却有一张床，一个浴缸，一个天窗。都是极尽惬意的事物，稍稍想象下，心里都会痒。可惜，我们虽然订了青瓦阁楼，但却以免费升级的名义被请往一层的主人房。未免遗憾。</p>
<p>住的房里，有天来了只老鼠，趁着人们酣睡的深夜，偷吃了一个大苹果。它仅咬下了一小块，但肉啃的很干净，留下些细碎的皮屑。以留作清早与我们分享。“这么一说，其实真是件恶心的事情。”(大笑)</p>
<p>不知道那只小老鼠，偷吃时心情该有何等愉快。里屋的那位喵星人应该并没有打扰它的兴致。</p>
<p>关于房间结构与村落构造，Jian说的清楚明白，那也是那篇文章最动人的地方。多看了几遍，心里便有些微醺了。不得不叹服Jian的文字造诣。</p>
<p>可心刚刚化开，Jian就开始提到了人。</p>
<p>世界上的人，大体上分为两种人格。伟人和英雄——伟人是庸人的最高体现，而英雄，是必有一面极其超凡，始终不安太平的。而这个世界毕竟庸人众多，所以伟人往往取得最后的“胜利”，所谓胜者为王，历史上记载着一大串的伟人。而，这些人，真正的英雄都是看不上眼的。不谈化名的主人当初的决绝，我宁可理解成他心里英雄的种子发了芽，世俗的胜利，在他的心里，被古旧平淡的瓶瓶罐罐挤的没了位置。Jian和我也有这样的种子，而她想将之送给化名，而我偷偷藏到了阁楼。我俩都被莫名的暗流推到了通往伟人的路上，这条路像村里入夜后的羊肠小道，远处泛着幽冷的火光，看不到头。还记得那晚Jian面对这条路时紧张而急促的呼吸。</p>
<p>其实，在她身上，我能看到拜伦的影子。那是人类文化的最强音，反对权威，崇尚自由，绝对的个人自由。那是英雄之路的终极。</p>
<p>还说青瓦阁楼。</p>
<p>当地人多以经商为主，惯于敛财，这样的习惯集中表现在了天井上。整座楼房仅有天井一处采光，阳光满满的洒在天井里，像黄金；待到冬天雪季，白雪满满的落在天井里，像白银。这样的想象，是对钱财的意淫，充满着俗气。我倒是想象着雨天的天井，雨水滴落在天井里，听雨能听的无比真切，伸伸手就能感受雨水的清凉，而不至于被淋湿。真是恰到好处的设计，特别美。</p>
<p>但对天井仅限于想象，二进上三层的楼阁却是喜欢的真切。</p>
<p>那里，可以感受到四面八方的风，每扇窗都有不同的景致，或远山，或清池，绿绿葱葱，延绵天边。看得累了，就坐下，捡起几本古书，细细品读。那里，你的心可以十分的平静，可以安放得住，可以平躺。这时候，才能品鉴的出书中的古意，会心一笑，怡然自得。那里，你可以忘掉在世俗中的一切，唯有清风和明月。可以拉着你想拉着的手，呢喃，旖旎。那里，你的世界显得十分清晰分明，你能感受到自己的存在，你能确定，你是自己的王。</p>
<p>可是，阁楼若没有基石，岂不成了空中楼阁？底层的屋子，透着规矩，谨然的很，两侧对联，环抱着道义。对着厅堂，守着礼节，一切井然有序。静处在那里，甚至想象出清人的作揖，品茶，聊天，读书。“二字箴言惟勤惟俭，两条正路曰耕曰读”，Jian说，古人可选的道路无比明确。我脑海里却泛起功名利禄之独木桥上的悍然厮杀。</p>
<p>写到这里，就能看出此楼的隐喻。古人讲究内圣外王，固是一理。一楼接待来往宾客，处处是人情世故；阁楼作为独处之所，琴棋书画，是隐蔽的个人精神世界。要想保得住个人的小宇宙，既要做到<strong>世事练达</strong>，又要做到<strong>淡定通透</strong>。这都是修炼的功夫。</p>
<p>平静如镜，干净如水的青瓦阁楼，若是没有底下规规矩矩的支撑，恐怕只是镜花水月。</p>
<p>所以，青瓦阁楼是属于神的，底层的担当，高阁的隐逸，那早已不是凡人。</p>
<p>正如这里的主人，看似不流俗，极富个人魅力，可如果不是通晓人情，岂能在此村立足？干净的是山水，青石板掩盖了人与人之间卑劣的暗渠。</p>
<p>不如，你做青瓦，我做楼阁。成为各自的英雄，互补成神。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[井场实时数据采集器开发日志]]></title>
        <link href="work/about-collector"/>
        <published>2013-04-05T00:00:00.000Z</published>
        <updated>2013-04-05T00:00:00.000Z</updated>
        <id>work/about-collector</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>以前为了让DLL内部拥有更多的控制权，将采集间隔的控制放到了DLL中。但现在需要将实时数据显示出来，那么第一次调用DLL的时候，就无法立刻显示数据，而是需要等待一轮间隔时间。这就给用户造成一种很不灵敏的感觉。于是这次我将采<strong>集间隔的控制从新放回了DLL调用外部</strong>。</p>
<p>采集器的开发基本告一段落。这一次完全是速成式的开发节奏。虽然我很小心翼翼的力图让代码结构清晰，功能明确，小巧易改。但是最终，在我五一放假归来后，嗅到了代码的臭味。</p>
<p>是的，我的代码有了不好的味道。</p>
<p>起初，我的设想是，尽量开发可以复用的小模块，我开发完，别人也可以直接利用。而且力求一个模块只做好一件事，这是借鉴了UNIX思想的。可是我忽略了一个情况，我并没在Unix/Linux上开发项目，而是在windows。这就出现了很可笑的情况，我开发的小模块，看似灵活可拆分，实际呢，却没有人可以用。</p>
<p>问题首先暴露在界面上。人的一生有许多追悔莫及的事情，而这样的悔恨多来自于对坏习惯的熟视无睹，或是，每次都挑选简单熟悉的方式解决问题，即使明明知道那并非最好的解决方法。人总会向自己的惰性妥协。对于传统的C++程序员来说，MFC就是这样一个陋习。而我早知如此，却一直未能摆脱这段噩梦。</p>
<p>2011年我首次接触MFC，觉得还蛮新奇，毕竟除了Java Web以外，我并不知道该如何构建一个界面。不过我坦言，两年来，我虽然用MFC开发了好几个小程序，但仍然没有真正的学明白MFC。正是因为这样的原因，每当我发誓弃MFC而去的时候，总会有一个声音嘲笑自己：半途而废的东西，没真正明白一项技术，没有权利批驳它。</p>
<p>于是，我努力在<a href="http://www.codeproject.com/">codeproject</a>这样的网站上寻找开源项目来提升自己的见识和实力。一次又一次的优化自己手里的项目。毕设就不提了，完全是玩具项目。工作以来，接过师傅的VC6程序，就一直琢磨着改造。直到如今，简化到采集器这样简洁清晰，着实费了一阵功夫。但，两年以来，一直局限在MFC里无法自拔，逐渐就脱离了日新月异的技术浪潮。</p>
<p>但MFC真的无法解决很多问题：</p>
<ol>
<li>多文档太过重量级，除了大型的应用程序，不会用到。而在一个Web和移动应用盛行的今天，很难再有重头开发大型的桌面程序的机会了。基于对话框，我想是大多数人最经常的选择。而，即使是基于对话框，也需要循规蹈矩的生成一个千篇一律的框架结构，其中大部分东西都不会用到，MVC结构根本不清晰，大部分代码集中在V这层。结构很是冗余，而且生成代码过多导致修改起来十分费劲。</li>
<li>可用控件少的可怜，而且老化严重，比起同门师兄C#来说，既丑陋又贫困。VS2010里加了许多以MFC开头的特殊控件，想力挽狂澜，可惜用起来并不灵活，相关文档也很稀少。而且控件的绑定与之间的通信，都十分费劲。资源文件里一不小心就会有冲突。设计好的界面也很难有复用性，一般都是用打开的方式，复制rc文件。可是界面关联的逻辑和变量咋办？与已有界面元素冲突咋办？都能办，就是繁琐的很。往往复制来复制去，还不如重新拖拽一个。想做点界面美化的工作？别想了，费老劲还没个结果。</li>
<li>充斥着大量的个性方法，我承认，CString的很多方法都很好用，完胜std::string，但是很多底层的类都是用纯C++或纯C来写的。怎么结合呢？从效率角度思考，使用Unicode工程，好了，代码里各类W2A和A2W，仅字符串来讲，就会需要各种转换，弄熟悉了也觉得代码很乱。另外，MFC的容器真的很屎，完全无法与STL媲美。</li>
<li>跨平台是个大问题，不说Linux和Windows之间，就说Windows自己，在Win7下写出的程序，在XP或是win2003上完全走样。保守来说，不敢用太新的控件，否则总会出一些莫名其妙的问题。再说DLL，DLL很容易引起灾难的。稍微一个版本不一致，就会让整个应用程序不举。企图用DLL来让程序模块清晰，小巧玲珑，完全是个梦。而且MFC DLL真的很鸡肋，复用性如何考虑？纯C DLL要好很多，但是少了图形界面，很难实现界面组件化，随时可插拔。另外，移植性并不理想，VS2010编译的MFC程序，需要mfc的好几个dll，哦，你说为啥不编译成静态库？试试就知道，问题很多。</li>
<li>最让人难受的，还是MFC写的程序真的很容易发臭。我不知道如何描述这样的感觉，即使你在编写的时候，各种小心，力求清晰可修改。但真正需要你修改补充的时候，就寸步难行。不知道是咋回事。也不知道别人是否有这样的感觉。偶尔，你想着，这个功能我曾经写过，想抽出来，用到另一个工程中去，想着挺简单，不知不觉就会浪费好多时间。MFC的代码一点也不美，味道真的不好闻。</li>
</ol>
<p>以上五条，纯属个人吐槽，很多地方其实都是我自身的原因。但如果MFC是一个产品，我是一个用户，我就是不爱用，我想这是一个用户起码的权利。</p>
<p>我去年年底就发誓，配置小工具是我最后一个MFC作品，没想到今年又紧急开发了一个采集器。这绝对是最后一次了。</p>
<p>已经开始抽空学习QT了，QT的很多思维方式都很赞。虽然我还只是摸到了皮毛，但是已经嗅到了它的清香。</p>
<p>扯界面扯了这么远，其实界面只是一个因素。更可怕的是我误解了DLL。</p>
<p>采集器一共由五个DLL和一个EXE组成。EXE是主界面，用来呈现采集上来的数据。重要的功能全部分配到DLL身上来实现。五个DLL实现的分别是，连接服务器数据库，取得服务器数据库中的配置，采集仪器数据，处理仪器数据，将数据组织为WITS标准的UDP消息发送给服务器。取得配置DLL，主要替代了以前的配置小工具的功能，也完美的解决了XML、INI配置文件的繁琐。采集和处理DLL，主要继承了之前的DLL，改动不大，仅是简化。将打包DLL去掉，换成了发送的DLL，解决了共享的问题。</p>
<p>这样以来，程序结构看起来很清晰，每一个DLL干好自己的事情就行了。而且连接数据库和取得配置的DLL都是带界面的，属于具备MFC类的C Dll。我想着，这可以实现复用。还故意把接口弄成了读写文件形式，这样耦合度很低，即使没有DLL，EXE照样可以运转。而我们这个项目，</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[写在2012的尽头]]></title>
        <link href="life/end-of-2012"/>
        <published>2012-12-31T00:00:00.000Z</published>
        <updated>2012-12-31T00:00:00.000Z</updated>
        <id>life/end-of-2012</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>年底总会写很多总结，学生时代为了给老师看，工作了是给领导看。什么时候才是给自己写的？以前总有这样的计划，直至今日，方才动笔。</p>
<h2 id="回忆">回忆</h2><p>1月份的时候，公司发了年终奖，还有一大堆福利，看到自己总算有了工资，心里难免会激动一场。而2011年的下半年，基本再为乔布斯而疯狂，于是，拉着Mr.Fox一起，走了一遭西单大悦城的Apple专卖店。经过一番劈天盖地的忽悠，我拎着一台iMac就回家了。那算是第一次与苹果亲密接触，趁着新鲜劲，赶紧买了一本Object-C基础教程。立志要能够写出自己的App，最后可以在商店上架。理想很丰满，现实很骨感。这本Object-C基础教程，除了第一章，之后都干净的很。原因是因为当时的工作任务，不怕不好意思，那时我第一次知道了用纯正的C++写类的感觉，而且还更进一步的写了一个基于观察者模式的框架。那种感觉实在爽到不行，再加上新来的组长是一个有20年C++编程经验的高手，于是乎我日日加班加点。苹果梦，不知不觉就淡忘了。</p>
<p>2月来的很快，那时我心有揣揣，领导突然安排我去西安出差。什么Object-C，什么观察者模式的消息队列，手还没有热乎，就要收拾行囊准备独自上路了。初到西安的时候极其不习惯，陌生的同事，完全不同的工作模式，我当时攒了一肚子怨气，于是搞砸了计划好的与北京同事的远程合作。那消息队列框架算是我来公司第一个像样的作品，却在襁褓之时就被告知放弃，这是如何也无法马上接受的。因此还差点和同事闹了矛盾。本月算是今年的第一次逆转，接收到两个教训：其一，工作要明确责任，做好自己的事情，不要老是盯着别人的活；其二，减少文字性聊天，如QQ，很容易产生理解性误会。</p>
<p>3月，人已在甘肃庆城县，遍眼的黄土还不算寂寞，荒野里住一宿也没有太意外。可是下旬近半个月没有和人类说一句话，的确有些难受。那段日子一个人在宾馆里，领导又没有切实的给我安排什么具体的任务，只好拿着一本Ruby入门开始学起了Ruby，当时，除了ios，最想学的就是ruby，没有很明确的目的，就是兴趣所致。当时还研究了好一会《番茄工作法》，但后来完全用不上，因为宾馆里除了睡就是吃，没有交流没有沟通，更不会有什么人会打断你。这里我漏掉了一环，从二月开始，我就想复习今年的考研了，对于一份这样的工作，我并没有找到做下去的意义，只是觉得读一读研究生可能会把一些事情想的更明白。于是二月还西安的时候，我就在当当网上买了很多考研复习的书籍，也很有计划的开始看高数和C语言了。三月上井，却没能带上这许多。这才彻底放开，去看Ruby的。</p>
<p>好不容易适应了孤独的日子，带我的师傅和以为年长的同事突然从现场赶回了庆阳。通知我一起去内蒙古的乌审旗，最后把我仍在了乌审旗的一个井场上，呆了四天的时间。井场上那带沙的饭和数的过来的几个冷菜，我都已经熟悉了。甚至连录井房的那几位技术员也聊得很开，但这样的日子毕竟过的荒诞，期间我多次催促项目组来接我下去，现在想想其实真没必要。后来项目组把我带回了乌审旗，我独自走在陌生的内蒙风情的大街上，心里只想着赶紧回家。回西安的大巴很颠簸，我中途拉了肚子，但由于车在高速上跑，没有办法停，只好忍了一路，只记得下车时的无比狼狈。</p>
<p>4月已经在西安，当时有点旅游控，就想着走天涯，去远方，独自远行之类的。于是总算在西安市内好好转了转，陕西历史博物馆给了我很深的印象。从小对有历史的东西就有莫名的痴迷，在不算大的博物馆里，从上午9点一直待到了12点多，出来时才感觉到了饿感，才在门口吃了一碗牛肉面。之后就去了大雁塔、慈恩寺，沉浸在自己营造的诗情画意中，倒也心满意足。这个月对于考研的坚持就没有那么的强烈了，对于网上各种新潮的技术都有了兴趣，看看这瞧瞧那，没个定性。但一个同事启发了我对于octopress的认识，那算是我第一次动手倒腾极客的事，这才诞生了这么一个简陋的个人Blog，不管怎么说，都很开心，中间由于公司内网的障碍，也遇到挺多的问题，但都一一解决掉了。这个月，让我在技术上的眼界更加的开阔了，风格上也更加的大胆激进了些，不管懂不懂，动手试试再说。下旬，西安的领导让我改进师傅的程序，我也恰有此意，当时我只是想尝试用自己的方式来重新实现师傅的程序（其中很大的原因是我不愿意在用VC6那样碍眼的编辑器了。。。），但我设想的有点太大，几乎把我见过的技术全都想用一遍，于是这个程序就演变成了一个具备socket传输、打包服务、全套的XML配置等的小框架，基本呈现一个C/S模式。但由于技术不精，交流不畅，与另一个负责远传的同事发生了一些激烈的争吵，这个小框架虽然被我自豪的上传了github，但最终还是不了了之了。可是，这个小框架算是我第一次肆无忌惮的独立设计，期间对很多的小工具与C++编程的思路都有了很好的沉淀，为下半年设计井场数据采集中间件流水线框架打下了坚实的基础。4月算是一个技术提升月。</p>
<p>5月的开头，为了满足自己的旅游梦，与师傅和另外一个同事一起，走了一趟洛阳和嵩山少林寺。地方俗得很，但玩的很舒服，至少爬山算是爬爽了。第一次对山间清新的空气有了无比的迷恋，深深的厌恶都市里充斥尾气的环境。旅游的确能让人明白许多事，能让人放开很多事，但也不知不觉花了许多钱。有失有得吧，但总算有些缓解了我对于旅游那种极度浪漫主义的渴望。就那么回事吧，山清水美又能怎样，关键是你与谁携手。回来后，立刻就收到了上井通知，这一去就是半年的旅程。</p>
<p>5、6月我遇见了很多人，要比我以前一两年遇到的人都多，也遇到了许多事，让我这娇生惯养的小皇帝体验了一把劳动人民的艰辛。这里不得不提一下遇到的极品同事王小贱，这位纯正的90后是第一次上井，但却有着丰富的江湖经验。早年就和我师傅一起在阳台上抽过烟，所以这次并没有太多生涩的感觉。小贱对于生活的理解及其简单，吃喝玩乐一样也不能少，年纪轻轻，对于嫖赌已经见怪不怪。从他身上，我顿时觉得自己有点白活，十几年的学校生涯，让我并不知道外面的世界原来有这样多的花样，遇到他简单至极的生活理念，我一肚子的思想道理也无处倾泻。但小贱这样玩得转的人，是不会屈膝做一些具体事情的，师傅也没理由动手，于是在井上，我满头大汗跑东跑西，又是抬箱子又是埋网线，上至房顶，下至床下，左手U盘，右手签单，嘴里还要给技术员们培训。只记得那段日子很痛苦，却又没法诉苦，只能小心翼翼的配合。而他们却照常嘲笑我在车上重重的鼾声，急急忙忙的小便。这些只是小事，但小贱对于报销上玩的手段却让初涉社会的我猝不及防。不管怎么说，这两个月里，我知道了太多社会上的事情，我眼见着认识三天的人称兄道弟酒醒酒醉，我也明白了一根烟、一杯酒竟能轻轻松松破除人与人之间的隔阂。小贱如果不是对于小钱小利太过猴急，我甚至看不清他的真实面孔。这让我知道，出门靠朋友，但更要靠自己。</p>
<p>6、7月，上井已经成了家常便饭，在外漂泊的日子算是倦了，认识的新同事越来越多。老江湖去玩女人，屌丝儿只好dota。那一段日子除了修改程序时的充实感外，灯红酒绿、觥筹交错与11平台上的开黑都让我事后倍感空虚。所谓闲，就是在宾馆里一起抱怨工作一起想家；所谓忙，无非就是陪领导喝酒侃大山，给领导交报告，满足领导天马行空的需求。但也不能算是完全荒废，起码我学会了在外如何与别人相处，如何游离在亲密与疏远的中间地带。如何与那些社会上的老油条们谨慎相处。如何凝聚自己所在的团队等。但核心还是想家，厌倦了东飘西荡的感觉。</p>
<p>8月份基本已经确定了回京的事宜，月初从北京休假归来，在西安感受到了强烈的寂寞感，还好一位帅哥同事友情援助让我安稳度过一晚。第二天坐上到延安的高铁，再坐大巴到了志丹与师傅们会和，但很快师傅就已经离去。独留我一个人带队实施。那段日子还是挺有成就感的，因为完全由我来安排一切，当时我积极的改版新程序，同时也积极的辗转陕北到处上井。从志丹到吴起，从吴起到安塞，又从安塞抵达靖边，一路上结交了许多当地项目组的人。曾经青涩稚嫩的我也能装模作样的游刃有余于合作与交流中。由于队员与司机的疲惫，我只好一个人上路，再次乘坐大巴去了定边的冯地坑与另一个小队汇合，在那里才认识了<a href="http://www.cnxp.org">冰魂网络</a>的站长IceSoul，这家伙年过三十还打着光棍，却还自娱自乐的玩弄着各种小技术，是个标准的极客+屌丝。从他那里，很多对于windows系统方面一知半解的知识都得到了验证和解释。他早年编写的许多小工具都让我大开眼界，也算是我在现实中第一个遇到的偏骇客的家伙了。那段日子有趣极了，我们每到一个旅馆，都将旅馆的路由器进行整改，以保证我们房间能够有足够的网速来dota。但并非每一次都能得逞，最后在庆阳的时候，我们摸到了人家的视频监控系统，却没能破解了其密码，确是遗憾。在他的催促下，我将井场自动采集软件做了最后的整改，配合他编写的配置小工具，倒是相得益彰。</p>
<p>8月绝对是神奇的一个月，除了上述的辗转陕北与到处捣蛋，竟还莫名其妙的遇到了我生命里的冤家，刚认识她的那几天，每天我都像打了鸡血一样，抱着心爱的iPad和她胡天海地的聊着，用我妈的话来说，就是把她和我爸一辈子的话都在那几天内说完了。现在想起来，会觉得滑稽，捧着一个iPad不玩游戏不看电影不看电子书，只用iMessage和一个不曾谋面的女孩聊天。实在奇葩的很。不知道哪里来的自信，和她聊完的第二天，我就有强烈的把握可以搞定她（可是这样的感觉并未持续很久）。正是因为这隐隐约约的暧昧情迷，才会出现上文所述那种需要别人催促才去编程的尴尬状况。写到这里突然不愿意多回忆关于她的点滴，因为每一天都记得十分清晰，从8月19日的第一封短信开始，直到如今。这并不需要总结，更不需要——回忆。就像阿里巴巴得到了四十大盗的宝贝，尽管情不自禁的让大门露出了一点缝隙，但立刻就会掩上，生怕别人知晓了去。</p>
<p>9月的第一天，我已经在北京上班了。从微博的数量就能看出来那阵子我的兴奋，爱情工作友情，重新回到了我的生命里，让寂寥的荒野，硬是长出了青苗。但爱情里有甜蜜势必就有苦涩，白璧微瑕更像是真实，娇艳的花朵总需要有破壳的过程，痛过方知不易，失去才知珍惜。月底更显忙乱，略去流水，算是留白吧。</p>
<p>10月初，去了一次舟山，参加表哥的婚礼。乱糟糟的幸福充斥着难闻的气味，我并未留下太多好的记忆，倒是后来去老家山上待的那几夜，映着月光在屋顶通电话的静谧让我难忘。青山绿水，流转着浓郁的思念。粗茶淡饭，消磨着转瞬的悲欢。梦里总会出现很多的如果，如果这样，如果那样。但最后还是要坚强的面对现实，学会理解，放下虚幻。</p>
<p>10月后的日子，重新投入到了工作中，凭借着一年的技术积累与实践经验，总算在一个月内，完成了对师傅采集程序的重构，并远远超出了原有程序的架构，运用了我所了解的全部技术。那段日子在工作上过的十分骄傲，数据采集流水线框架，成了我真正意义上的一个产品，一个实用的作品。那段时间总认为自己可以改变世界，正在改变世界，其实实事求是的说，我仅仅是沉淀了以往所有的技术积累，数据库，字符串处理，XML，INI，动态链接库。这些只不过是一个C++程序员的基本功而已，并不值得一提。网络、图形图像、并发处理，这些经典的领域还很遥远。可无论如何，我从中获得了满足与快乐，享受着这段不断实现想法的日子。</p>
<p>11月到12月，中途弄了阵Java，因为两位同事的调离，所以接替了他们的程序。并未感觉多么陌生，反而重新有了兴趣。甚至在网上找到一个很棒的SWING框架，琢磨了好几天后，突然发现它价格不菲，于是果断放弃了。又有几次开会推翻了之前的想法，一心要用什么ActiveX来做伪B/S。无奈我只好改用熟悉的MFC来迎接变化。轮到自己设计人机交互的程序了，才明白界面设计有多么的力不从心。我们只是程序员，哪来的美工那样挥手即来的艺术灵感。庆幸的是在今年的最后一天，这个采集配置器的小工具总算成型。我保证，这将是我最后一个MFC作品。。。</p>
<h1 id="总结">总结</h1><p>许是恋爱谈久了，写的文字又臭又长。在她面前小心翼翼不敢乱说话，自己写起来就各种大白话，不加修饰。能有耐心看到这里的，怕是只有我自己了吧。</p>
<p>总体来说，2012比2011过的更加奇幻，更加的有意义。有心摘的花没开，无心插的柳成荫。世事无常，人生无解。</p>
<p>最后废话几句吧：</p>
<ol>
<li>彻底阉割了考研梦，国内的研究生学习不值得向往，将目光聚焦大洋彼岸。</li>
<li>借用某人的话，研究技术不要秒射，年初的ios和ruby都是一时心血来潮之举。4月搞了一阵子C也是三天打鱼。要不是工作原因，C++都不会得到应有的沉淀。</li>
<li>工作了就不要和学生那样思维单纯，说话做事之前多想想，人际关系很微妙。守住底线，摈弃固执，沉住气，用心去理解。</li>
<li>不仅仅是技术，下半年回京后的英语、跑步都有间断，人最难对付的是懒惰。</li>
<li>仅发烧了两次，值得表扬，运动不能弃，身体最关键。</li>
<li>爱情，是顺其自然。</li>
<li>工作讲究划分责任，多听少说，多做少怨。注意积累工作经验与方法。</li>
<li>QQ交流最没效率，容易误会容易激动容易伤人，请拿起手边闲置的电话。</li>
<li>少说那么多道理，放下身段，听听别人怎么说，看看别人怎么活。</li>
</ol>
<h1 id="明年关键词">明年关键词</h1><p><strong>专注</strong>，<strong>坚持</strong>，<strong>放低自己</strong> ，<strong>大胆去做</strong>，<strong>沉住气</strong>。</p>
<p><em>英语要听</em>，<em>托福</em>，<em>C</em>，<em>学习前台网页设计</em>，<em>C++的基础</em>，<em>操作系统与网络</em>。</p>
<p>最后，但最重要：</p>
<blockquote>
<p>她</p>
</blockquote>
<p>&lt;--全文完--&gt;</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Call Function By Name?]]></title>
        <link href="study/call-function-by-name"/>
        <published>2012-12-11T15:22:00.000Z</published>
        <updated>2012-12-11T15:22:00.000Z</updated>
        <id>study/call-function-by-name</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>今天项目中需要通过读取数据库中的字符串，由字符串的值来确定调用哪一个方法来进行操作。我们不可避免的需要写if语句来匹配字符串，然后调用相应的函数。</p>
<blockquote>
<p>实际上在windows上，更方便而高效的是将要调用的方法都写在dll中，但项目进行到这个阶段，那些成群结队的方法早已经写好，封装成类，且被多个模块调用着，如果将之提取到dll，避免不了有大面积修改。于是，我只好尝试采用最笨拙的方法。</p>
</blockquote>
<p>其实，有点回调函数的意思。大家说说呢？</p>
<p>看代码吧：</p>
<div class="highlight"><pre><code class="cpp"><span class="comment">//</span>
<span class="comment">//  main.cpp</span>
<span class="comment">//  NameTodo</span>
<span class="comment">//</span>
<span class="comment">//  Created by 陈 培哲 on 12-12-11.</span>
<span class="comment">//  Copyright (c) 2012年 陈 培哲. All rights reserved.</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> fun1(<span class="keyword">void</span>)
{
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"function 1:\"int fun1(void)\" is called"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">1</span>;
}

<span class="keyword">int</span> fun2(<span class="keyword">void</span>)
{
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"function 2:\"int fun2(void)\" is called"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">2</span>;
}

<span class="keyword">int</span> fun3(<span class="keyword">void</span>)
{
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"function 3:\"int fun3(void)\" is called"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">3</span>;
}

<span class="keyword">typedef</span> <span class="keyword">int</span> (*fun_ptr_t)(<span class="keyword">void</span>);

<span class="keyword">typedef</span> <span class="keyword">struct</span> str_fun_t
{
    <span class="built_in">string</span> name;
    fun_ptr_t ptr;
}str_fun_t;

<span class="keyword">void</span> bind(str_fun_t *key, <span class="built_in">string</span> name)
{
    <span class="keyword">static</span> str_fun_t str_fun_array[]=
    {
        {<span class="string">"fun1"</span>,fun1},{<span class="string">"fun2"</span>,fun2},{<span class="string">"fun3"</span>,fun3}
    };

    <span class="keyword">int</span> i;
    key-&gt;name = name;
    key-&gt;ptr = NULL;

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str_fun_array)/<span class="keyword">sizeof</span>(str_fun_t); i++)
    {
        <span class="keyword">if</span> (key-&gt;name == str_fun_array[i].name) {
            key-&gt;ptr = str_fun_array[i].ptr;
            <span class="keyword">break</span>;
        }
    }
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])
{

    <span class="comment">// insert code here...</span>
    <span class="built_in">string</span> name(<span class="string">""</span>);
    str_fun_t key;

    <span class="built_in">cout</span> &lt;&lt; <span class="string">"your function name:"</span> &lt;&lt; endl;
    <span class="built_in">cin</span> &gt;&gt; name;
    bind(&amp;key,name);
    <span class="keyword">if</span>(key.ptr)
        key.ptr();
    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"the function "</span> &lt;&lt; key.name &lt;&lt; <span class="string">" can not be found"</span> &lt;&lt; endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre></div><p>运行结果：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/result.png" alt="result"></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[乌审旗的夜]]></title>
        <link href="life/night-in-wushenqi"/>
        <published>2012-05-19T13:55:00.000Z</published>
        <updated>2012-05-19T13:55:00.000Z</updated>
        <id>life/night-in-wushenqi</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <blockquote>
<p>乌审旗，五马路附近，傍晚，微风。</p>
</blockquote>
<p>本来只是出去走走，但走到冷清处，忽然很想跑步。</p>
<p>一位蒙古族的老人，静坐在这不知名的广场上，天很暗，看不清她脸上的神色，也许仅是疲乏了。但加上了我的想象，只感觉无比虔诚，万籁俱寂。又跑了一会，看见，一位街道保洁服装的女人站在道牙子上，拥抱着一个骑着摩托的小伙子。是述说心事，是表达爱意，还是倾听悲伤？在我的眼里，恰是一幅小城风情的油画，不同的人，能从其中看到不同的故事。</p>
<p>今天的文字写的很慢，因为忽然觉得我善于抒情说理，并不善于描述渲染。文字缺乏现实的力度，少了观察的功夫，属于言之无物，有些说教的意味。</p>
<p>来到这个陌生的城市，遇到很多困难，受了很多委屈，我努力的不让自己在文字里抱怨。尽量展现我所看到的真实世界，活生生的人。也许在象牙塔里待得太久，陷得太深。习惯与书中人交流，面对赤裸裸的人性，却显得有些生疏尴尬。</p>
<p>多观察、多思考，也许是浮躁的太久，需要多一些经历来沉淀。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[VC处理XML的方法]]></title>
        <link href="study/vc-process-xml"/>
        <published>2012-04-25T00:54:00.000Z</published>
        <updated>2012-04-25T00:54:00.000Z</updated>
        <id>study/vc-process-xml</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>目前调研到两种比较好的方法：<code>CMarkup</code>和<code>TinyXML-2</code>。</p>
<p>以下是两者分别的文档：<a href="http://www.firstobject.com/dn_markupmethods.htm">CMarkup</a>，<a href="http://www.grinninglizard.com/tinyxml2docs/index.html">TinyXML-2</a></p>
<p>从上手的难易程度来看，目前偏向于使用<code>CMarkup</code>，不过有机会一定要研究一下<code>TinyXML-2</code>的使用，目前关于<code>TinyXML-2</code>的中文资料较少，正好花时间翻译整理一下。另外，它不仅开源，而且功能较<code>CMarkup</code>要全面，文档更加齐全。</p>
<p>下面首先说一下<code>CMarkup</code>的基本使用方法：</p>
<p>首先在<a href="http://www.firstobject.com/dn_markupmethods.htm">这里</a>下载<code>CMarkup</code>，里面包含一个<code>Markup.h</code>和<code>Markup.cpp</code>。分别引入自己的项目下。</p>
<p><strong>NOTE:</strong> 貌似<code>CMarkup</code>仅支持MFC，在控制台程序中似乎无法使用。</p>
<p>在引入之后，需在在<code>Markup.cpp</code>的头部加上<code>#include &quot;stdafx.h&quot;</code>，在下述<code>testXML</code>工程里，不再赘述这一过程。</p>
<h2 id="创建xml">创建XML</h2><ol>
<li>新建一个MFC工程(<code>testXML</code>)，选择基于对话框的就好，其余一切默认。</li>
<li>在对话框上新建一个按钮(<code>Create</code>)，添加<code>BN_CLICKED</code>控件事件。</li>
<li>在事件函数中写入一下代码：</li>
</ol>
<div class="highlight"><pre><code class="cpp"><span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtmCreate()
{
    <span class="comment">// 创建XML</span>
    CMarkup xml;
    xml.AddElem( L<span class="string">"ORDER"</span> );
    xml.IntoElem();
    xml.AddElem( L<span class="string">"ITEM"</span> );
    xml.IntoElem();
    xml.AddElem( L<span class="string">"SN"</span>, L<span class="string">"132487A-J"</span> );
    xml.AddElem( L<span class="string">"NAME"</span>, L<span class="string">"crank casing"</span> );
    xml.AddElem( L<span class="string">"QTY"</span>, L<span class="string">"1"</span> );

    xml.Save( L<span class="string">"F:\\Sample.xml"</span> );
    MessageBox(L<span class="string">"Success!"</span>);
}</code></pre></div><p>我们仅运用了两种方法：<a href="http://www.firstobject.com/dn_markAddElem.htm">AddElem</a>和<a href="http://www.firstobject.com/dn_markIntoElem.htm">IntoElem</a>，前者可以理解为增加一个标签，后者则是进入此标签，很简单的逻辑。</p>
<p>以下就是生成的XML示例：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">ORDER</span>&gt;</span>
<span class="tag">&lt;<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SN</span>&gt;</span>132487A-J<span class="tag">&lt;/<span class="title">SN</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>crank casing<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">QTY</span>&gt;</span>1<span class="tag">&lt;/<span class="title">QTY</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ORDER</span>&gt;</span></code></pre></div><p>千万不要忘记了保存。即调用<code>XML.Save();</code>。</p>
<p><strong>NOTE:</strong> 这里有一点很囧，就是保存路径无法写<strong>相对路径</strong>。如果有知道如何写入相对路径的，请留言告知，感激不尽。 </p>
<h2 id="读取xml">读取XML</h2><p>我们就来读上面写好的<code>Sample.xml</code>吧。如果在同一函数中，完全可以用<a href="http://www.firstobject.com/dn_markGetDoc.htm">GetDoc</a>方法重新读取该文档：</p>
<pre>MCD_STR strXML = xml.GetDoc();

</pre><p><code>Markup.h</code>中定义了<a href="http://www.firstobject.com/dn_markmcdstr.htm">MCD_STR</a>作为默认的字符串类型，你也可以使用<code>std::string</code>或者<code>CString</code>。然后可调用<a href="http://www.firstobject.com/dn_markResetPos.htm">ResetPos</a>方法来返回文档头部。或者咱们重新写个函数，专门来读：</p>
<p><em>再在对话框上新建一个按钮(<code>Read</code>)，并添加<code>BN_CLICKED</code>事件。写下代码：</em></p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtmRead()
{
    <span class="comment">// 读取XML</span>
    CMarkup xml;
    xml.Load(L<span class="string">"F:\\Sample.xml"</span>);
    <span class="comment">//MCD_STR strXML = xml.GetDoc();</span>
    <span class="comment">//xml.SetDoc(strXML);</span>

    xml.FindElem(); <span class="comment">// root ORDER element</span>
    xml.IntoElem(); <span class="comment">// inside ORDER</span>
    CString outPut;
    <span class="keyword">while</span> ( xml.FindElem( L<span class="string">"ITEM"</span>) )
    {
        xml.IntoElem();
        xml.FindElem( L<span class="string">"SN"</span> );
        MCD_STR strSN = xml.GetData();
        xml.FindElem( L<span class="string">"QTY"</span> );
        <span class="keyword">int</span> nQty = _wtoi( MCD_2PCSZ(xml.GetData()) );
        outPut.Format(L<span class="string">"SN:%s\nQTY:%d"</span>,strSN,nQty);
        xml.OutOfElem();
    }

    MessageBox(outPut);
}</code></pre></div><p>首先，需要声明一个<code>CMarkup</code>对象，然后用<a href="http://www.firstobject.com/dn_markLoad.htm">Load</a>方法引入需要解析的XML文档。或者使用<a href="http://www.firstobject.com/dn_markSetDoc.htm">SetDoc</a>方法(见被注释的两行代码)。</p>
<p>然后再循环调用<a href="http://www.firstobject.com/dn_markFindElem.htm">FindElem</a>与<a href="http://www.firstobject.com/dn_markGetData.htm">GetData</a>来定位并获取标签内容。这里如果需要的数字，可以通过<code>atoi</code>来转化字符串，如果在<code>Unicode</code>环境下，需要用<code>_wtoi</code>来转换。<a href="http://www.firstobject.com/dn_markunifiedstlmfc.htm">MCD_2PCSZ</a>在<code>Markup.h</code>中有定义，返回一个字符串的const指针。</p>
<p>最后要注意的就是，每一次定位到某标签，需要调用<a href="http://www.firstobject.com/dn_markIntoElem.htm">IntoElem</a>来进入子标签，并继而通过<a href="http://www.firstobject.com/dn_markOutOfElem.htm">OutOfElem</a>跳出。每一次循环一定由一对<a href="http://www.firstobject.com/dn_markIntoElem.htm">IntoElem</a>和<a href="http://www.firstobject.com/dn_markOutOfElem.htm">OutOfElem</a>来包夹。</p>
<p>运行结果如下：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/ReadXML.png" alt="result"></p>
<h2 id="添加标签及属性">添加标签及属性</h2><p>上面创建的XML仅仅包含一个ITEM标签。下面再举一个例子，通过已有的数据源创建多个ITEM。然后通过<a href="http://www.firstobject.com/dn_markSetAttrib.htm">SetAttrib</a>来为<code>SHIPMENT</code>标签设置一个属性。</p>
<p><em>在对话框上新建一个按钮(<code>Add</code>)，并添加<code>BN_CLICKED</code>事件。写下代码：</em></p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">struct</span> Items
{
    CString strSN;
    CString strName;
    <span class="keyword">int</span> nQty;
};

<span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtnAdd()
{
    <span class="comment">// 向XML中添加标签与属性</span>
    CArray&lt;Items,Items&amp;&gt; aItems;
    Items item1 = {L<span class="string">"132487A-J"</span>,L<span class="string">"crank casing"</span>,<span class="number">1</span>};
    Items item2 = {L<span class="string">"4238764-A"</span>,L<span class="string">"bearing"</span>,<span class="number">15</span>};
    aItems.Add(item1);
    aItems.Add(item2);

    CString strPOCType(L<span class="string">"non-emergency"</span>);
    CString strPOCName(L<span class="string">"John Smith"</span>);
    CString strPOCTel(L<span class="string">"555-1234"</span>);

    CMarkup xml;
    xml.AddElem(L<span class="string">"ORDER"</span>);
    xml.IntoElem(); <span class="comment">// inside ORDER</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> nItem=<span class="number">0</span>; nItem&lt;aItems.GetSize(); ++nItem)
    {
        xml.AddElem( L<span class="string">"ITEM"</span> );
        xml.IntoElem(); <span class="comment">// inside ITEM</span>
        xml.AddElem( L<span class="string">"SN"</span>, aItems[nItem].strSN );
        xml.AddElem( L<span class="string">"NAME"</span>, aItems[nItem].strName );
        xml.AddElem( L<span class="string">"QTY"</span>, aItems[nItem].nQty );
        xml.OutOfElem(); <span class="comment">// back out to ITEM level</span>
    }
    xml.AddElem( L<span class="string">"SHIPMENT"</span> );
    xml.IntoElem(); <span class="comment">// inside SHIPMENT</span>
    xml.AddElem( L<span class="string">"POC"</span> );
    xml.SetAttrib( L<span class="string">"type"</span>, strPOCType );
    xml.IntoElem(); <span class="comment">// inside POC</span>
    xml.AddElem( L<span class="string">"NAME"</span>, strPOCName );
    xml.AddElem( L<span class="string">"TEL"</span>, strPOCTel );

    xml.Save( L<span class="string">"F:\\Sample.xml"</span> );
    MessageBox(L<span class="string">"Success!"</span>);
}</code></pre></div><p>这段代码生成如下XML：根标签<code>ORDER</code>包含了两个<code>ITEM</code>子标签和一个<code>SHIPMENT</code>标签。该<code>ITEM</code>标签包括了<code>SN</code>,<code>NAME</code>和<code>QTY</code>子标签。<code>SHIPMENT</code>标签包含了一个<code>POC</code>子标签，<code>POC</code>拥有一个<code>type</code>属性，和一个<code>NAME</code>、<code>TEL</code>子标签。</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">ORDER</span>&gt;</span>
<span class="tag">&lt;<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SN</span>&gt;</span>132487A-J<span class="tag">&lt;/<span class="title">SN</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>crank casing<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">QTY</span>&gt;</span>1<span class="tag">&lt;/<span class="title">QTY</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SN</span>&gt;</span>4238764-A<span class="tag">&lt;/<span class="title">SN</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>bearing<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">QTY</span>&gt;</span>15<span class="tag">&lt;/<span class="title">QTY</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SHIPMENT</span>&gt;</span>
<span class="tag">&lt;<span class="title">POC</span> <span class="attribute">type</span>=<span class="value">"non-emergency"</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>John Smith<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">TEL</span>&gt;</span>555-1234<span class="tag">&lt;/<span class="title">TEL</span>&gt;</span>
<span class="tag">&lt;/<span class="title">POC</span>&gt;</span>
<span class="tag">&lt;/<span class="title">SHIPMENT</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ORDER</span>&gt;</span></code></pre></div><h2 id="查找标签">查找标签</h2><p><code>FindItem</code>方法默认查找<strong>下一个</strong>相邻的标签。如果其参数指定了标签名称，则一直向下查找，直到得到匹配的标签。找到标签的位置将被视为当前位置，下一次调用<code>FindItem</code>方法时，将以当前位置为开端，继续向下查找能够匹配的标签位置。</p>
<p>在FindItem循环查找过程中，如果不想继续顺序查找下去，而是希望返回到第一个标签的位置，可以用<a href="http://www.firstobject.com/dn_markResetMainPos.htm">ResetMainPos</a>。例如上述例子中，如果你无法确定<code>SN</code>标签是否在<code>QTY</code>标签之前(而你恰好又是先找的<code>QTY</code>)，那就可以用<code>ResetMainPos</code>方法返回重新查找。代码如下：</p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtnFind()
{
    <span class="comment">// 检索XML</span>
    CMarkup xml;
    xml.Load(L<span class="string">"F:\\Sample.xml"</span>);
    <span class="comment">//MCD_STR strXML = xml.GetDoc();</span>
    <span class="comment">//xml.SetDoc(strXML);</span>

    xml.FindElem(); <span class="comment">// root ORDER element</span>
    xml.IntoElem(); <span class="comment">// inside ORDER</span>

    CString outXml;
    <span class="keyword">while</span> ( xml.FindElem(L<span class="string">"ITEM"</span>) )
    {
        xml.IntoElem();
        xml.FindElem( L<span class="string">"QTY"</span> );
        <span class="keyword">int</span> nQty = _wtoi( MCD_2PCSZ(xml.GetData()) );
        xml.ResetMainPos();
        xml.FindElem( L<span class="string">"SN"</span> );
        MCD_STR strSN = xml.GetData();
        xml.OutOfElem();

        outXml.Format(L<span class="string">"strSN:%s\nnQty:%d"</span>,strSN,nQty);
    }

    CString strFindSN(L<span class="string">"87890310-A"</span>);
    MCD_STR strSN; 
    xml.ResetPos(); <span class="comment">// top of document</span>
    xml.FindElem(); <span class="comment">// ORDER element is root</span>
    xml.IntoElem(); <span class="comment">// inside ORDER</span>
    <span class="keyword">while</span> ( xml.FindElem(L<span class="string">"ITEM"</span>) )
    {
        xml.FindChildElem( L<span class="string">"SN"</span> );
        <span class="keyword">if</span> ( xml.GetChildData() == strFindSN )
        {
            strSN = xml.GetChildData();
            <span class="keyword">break</span>; <span class="comment">// found</span>
        }
    }

    xml.Save(L<span class="string">"F:\\Sample.xml"</span>);
    MessageBox(outXml+<span class="string">"\n"</span>+strSN);
}</code></pre></div><p>如果只是想找一个特殊的值(如上述代码中值为&quot;87890310-A&quot;的SN)，可以循环遍历<code>ITEM</code>标签，并比对其子标签<code>SN</code>的值。如果指定查找<code>ITEM</code>标签，如上述代码，那就不会去理其他标签，如<code>SHIPMENT</code>等。</p>
<p>另外，进出<code>ITEM</code>标签去对其子标签<code>SN</code>进行查找，使用<code>FindChildElem</code>和<code>GetChildData</code>方法要便捷的多。</p>
<h2 id="这就完了么？">这就完了么？</h2><p>额，准确的说，上述这点玩意儿，只是最最最基本的操作。不过完全可以看出<code>CMarkup</code>类的便捷简单了吧？利用<code>CMarkup</code>操作XML虽说已经是很成熟的技术了，但它的功能并不是太全面。这只是一种轻量级的工具，合适与否完全看个人需求了。更多的方法API请见<a href="http://www.firstobject.com/dn_markupmethods.htm">这里</a>。</p>
<h2 id="参考资料">参考资料</h2><p>[1] <a href="http://www.firstobject.com/fast-start-to-xml-in-c++.htm">Fast start to XML in C++</a></p>
<p>[2] <a href="http://www.firstobject.com/dn_markupmethods.htm">CMarkup Methods</a></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[关于Unicode编码]]></title>
        <link href="study/unicode-and-ansi"/>
        <published>2012-04-23T00:00:00.000Z</published>
        <updated>2012-04-23T00:00:00.000Z</updated>
        <id>study/unicode-and-ansi</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>很多Windows\C++的初学者对于<code>TCHAR</code>, <code>LPCTSTR</code>这些怪异的符号很头疼。(我有一个能力很强的同事便是如此，甚至因为这个丧失了对Windows开发的兴趣，转去做Java了。)今天就把这些玩意一探究竟吧。</p>
<h2 id="简述ansi与unicode">简述ANSI与Unicode</h2><p>显示某个字符，可以用单字节存储，也可以用双字节存储。前者便是我们常见的ANSI编码策略，适用于大多数的英系字符；后者则是Unicode编码策略，几乎可以用以表示世界上所有的文字。</p>
<p>在VC++编译器中，对应于以上两种编码方式，分别给出了<code>char</code>与<code>wchar_t</code>两种数据类型。<em>Unicode</em>还有诸多好处，但现在仅需知道它作为一种双字节存储方式可以更好的支持Windows程序的国际化。</p>
<blockquote>
<p>不止是Unicode，Windows还会用到更多别的双字节编码，如默认使用的UTF-16字符编码。</p>
</blockquote>
<p>作为程序员，一定希望自己的C/C++代码适用于所有的字符编码吧？</p>
<p><strong>建议</strong>：使用通用的数据类型来表示字符与字符串。举个例子吧，请把</p>
<pre>char cResponse; // &#39;Y&#39; or &#39;N&#39;
char sUsername[64];
// str* functions
</pre><p>和
    wchar_t cResponse; // &#39;Y&#39; or &#39;N&#39;
    wchar_t sUsername[64];
    // wcs* functions
替换成：</p>
<pre>#include&lt;TCHAR.H&gt; // Implicit or explicit include
TCHAR cResponse; // &#39;Y&#39; or &#39;N&#39;
TCHAR sUsername[64];
// _tcs* functions

</pre><p>这样就照顾了多语言环境的需求(就像Unicode)，是更加通用的一种形式。</p>
<p>在实际编码的时候，如在VS2010的环境下，可以这样设置编译时所用的字符集：(<em>常规-&gt;字符集</em>)</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/setUnicode.png" alt="setUnicode"></p>
<p>如上图所示，若设置为Unicode，<code>TCHAR</code>将视为<code>wchar_t</code>；若设置为多字节，<code>TCHAR</code>将被视为<code>char</code>。项目的具体设置不会影响到<code>wchar_t</code>或是<code>char</code>类型的使用了。为啥会这样呢，请看<code>TCHAR</code>的定义：</p>
<pre>#ifdef _UNICODE
typedef wchar_t TCHAR;
#else
typedef char TCHAR;
#endif

</pre><p><code>_UNICODE</code>宏的作用就是当项目&quot;<em>设置为Unicode字符集</em>&quot;时，<code>TCHAR</code>含义是<code>wchar_t</code>；&quot;<em>设置为多字节字符集</em>&quot;时，<code>TCHAR</code>含义是<code>char</code>。</p>
<p>与上述类似，为了支持各字符集都能使用最基本的函数，最好使用<code>_tcscpy，_tcslen，_tcscat</code>函数来代替<code>strcpy，strlen，strcat</code>(出于安全的考虑，常会在后面加上<code>_s</code>)或<code>wcscpy,wcslen,wcscat</code>(已经考虑了安全性)。</p>
<p>strlen的原型如下：</p>
<pre>size_t strlen(const char*);

</pre><p>wcslen的原型如下：</p>
<pre>size_t wcslen(const wchar_t* );

</pre><p>最好使用_tcslen，从<em>逻辑</em>上可将其原型表述为：</p>
<pre>size_t _tcslen(const TCHAR* );

</pre><p><strong>wc</strong>表示宽字符，可知<code>wcs</code>表示宽字符串，同理可知<code>_tcs</code>表示_T字符串，能猜到_T在逻辑上既代表<code>char</code>又代表<code>wchar_t</code>了吧？</p>
<p>不过，实际上，<code>_tcslen</code>(还有其他<code>_tcs</code>前缀的函数)并<strong>不是</strong>一个拥有完整定义的真实函数，而仅仅是一个<strong>宏</strong>。其定义应该长这样子：</p>
<pre>#ifdef _UNICODE
#define _tcslen wcslen 
#else
#define _tcslen strlen
#endif

</pre><p>在<strong><code>TCHAR.H</code></strong>中，会找到与之相似的准确定义。</p>
<blockquote>
<p>为何定义成宏，而不是直接定义为函数接口呢？</p>
</blockquote>
<p>原因很简单，lib或是dll只能导出单一的函数名与参数类型(这里不考虑C++的重载)。例如，你导出的是：</p>
<pre>void _TPrintChar(char);

</pre><p>而应用程序正好需要用到</p>
<pre>void _TPrintChar(wchar_t);

</pre><p>该怎么办呢？单字节参数不会无缘无故的变成双字节。其实那是两个不同的函数：</p>
<pre>void PrintCharA(char); // A = ANSI 
void PrintCharW(wchar_t); // W = Wide character

</pre><p>如果定义一个宏，就轻而易举的解决了这个问题：</p>
<pre>#ifdef _UNICODE
void _TPrintChar(wchar_t); 
#else 
void _TPrintChar(char);
#endif

</pre><p>届时，应用程序只需如此调用：</p>
<pre>TCHAR cChar;
_TPrintChar(cChar);

</pre><p>宏避免了两种字符集的共存，并允许我们可以运用ANSI或Unicode编码的函数来处理各类字符或字符串。大多数windows函数都采取了这样的措施，为了简化程序员的工作，只写一个函数(用宏去转换)是非常棒的解决方法。<code>SetWindowText</code>便是一个典型的例子：</p>
<pre>// WinUser.H
#ifdef UNICODE
#define SetWindowText  SetWindowTextW
#else
#define SetWindowText  SetWindowTextA
#endif // !UNICODE

</pre><p>极少数的函数没有采用宏，而是仅仅以<strong>W</strong>或<strong>A</strong>后缀作为区分。例如<code>ReadDirectoryChangesW</code>，它并没有ANSI编码的等价函数。</p>
<h2 id="ansi与unicode的转换">ANSI与Unicode的转换</h2><p>我们一般习惯用双引号来标记字符串。其实那是ANSI字符串的用法，其中每个字符均为单字节存储，例如：</p>
<pre>&quot;This is ANSI String. Each letter takes 1 byte&quot;

</pre><p>上述字符串<strong>不支持</strong>Unicode，对多语言环境的支持有限。想要表现为Unicode编码，你需要用到<code>L</code>前缀。例如：</p>
<pre>L&quot;This is Unicode string. Each letter would take 2 bytes, including spaces.&quot;

</pre><p>注意，<strong>L</strong>在字符串的前面，表明这是Unicode字符串。其中<strong>所有</strong>的字符都是双字节存储，包括英文字符、空格、数字、甚至是空字符。因此，Unicode字符串占用的空间将永远是2-字节的倍数。一个长度为7的Unicode字符串需要14字节，诸如此例。所以，永远不存在一个占用15个字节的Unicode字符串。</p>
<p>更通用的说法是，字符串所占空间都是<code>sizeof(TCHAR)</code>个字节的倍数。</p>
<p>当需要表示一个硬编码的字符串时，可以这样：</p>
<pre>&quot;ANSI String&quot;; // ANSI
L&quot;Unicode String&quot;; // Unicode

_T(&quot;Either string, depending on compilation&quot;); // ANSI or Unicode
// or use TEXT macro, if you need more readability

</pre><p>其中，无前缀的是ANSI字符串，<strong>L</strong>前缀的是Unicode字符串，以<code>_T</code>或<code>TEXT</code>标识的，将根据宏定义而定。还是一样，<code>_T</code>和<code>TEXT</code>只是宏而已，它们定义如下：</p>
<pre>// SIMPLIFIED
#ifdef _UNICODE 
 #define _T(c) L##c
 #define TEXT(c) L##c
#else 
 #define _T(c) c
 #define TEXT(c) c
#endif

</pre><p>这<code>##</code>符号是<a href="http://msdn.microsoft.com/en-us/library/09dwwt6y(v=vs.80).aspx">符号连接操作符</a>，它将<code>_T(&quot;Unicode&quot;)</code>替换为<code>L&quot;Unicode&quot;</code>，该替换取决于宏参数——<code>_UNICODE</code>是否被定义。如果没有被定义，<code>_T(&quot;Unicode&quot;)</code>意味着<code>&quot;Unicode&quot;</code>。<em>符号连接操作符</em>并不仅仅是VC或字符编码中的特定符号，它甚至存在于C语言中。</p>
<p>注意，该宏既适用于字符串，也适用于字符。例如<code>_T(&quot;R&quot;)</code>将被转换为<code>L&quot;R&quot;</code>或<code>&quot;R&quot;</code>。前者为Unicode字符，后者为ANSI字符。</p>
<p><strong>但，这无法转换变量(字符或字符串)</strong>。以下代码就是非法的：</p>
<pre>char c = &#39;C&#39;;
char str[16] = &quot;MyProject&quot;;

_T(c);
_T(str);

</pre><p>最后两句代码可以在ANSI(多字节)下编译成功，因为<code>_T(x)</code>就是<code>x</code>，因此<code>_T(c)</code>和<code>_T(str)</code>将分别输出<code>c</code>和<code>str</code>。但在Unicode字符集下编译，则会报错：</p>
<pre>error C2065: &#39;Lc&#39; : undeclared identifier
error C2065: &#39;Lstr&#39; : undeclared identifier

</pre><p>我们需要注意所有的字符、字符串操作的函数，尤其是windows API提供的那些，基本都是MSDN推荐的典范。拿<code>SetWindowsTextA/W</code>来说吧：</p>
<pre>BOOL SetWindowText(HWND, const TCHAR*);

</pre><p>想必应该知道了，<code>SetWindowText</code>仅仅是一个宏，它取决于你的编译配置，其含义可以是以下其中一个：</p>
<pre>BOOL SetWindowTextA(HWND, const char*);
BOOL SetWindowTextW(HWND, const wchar_t*);

</pre><p>因此，不要困惑于下面这段取地址函数为啥调用失败了！</p>
<pre>HMODULE hDLLHandle;
FARPROC pFuncPtr;
hDLLHandle = LoadLibrary(L&quot;user32.dll&quot;);
pFuncPtr = GetProcAddress(hDLLHandle, &quot;SetWindowText&quot;);
//pFuncPtr will be null, since there doesn&#39;t exist any function with name SetWindowText !

</pre><p><code>SetWindowTextA</code>和<code>SetWindowTextW</code>都由<code>User32.dll</code>所导出的。并没有通用的函数名。</p>
<p>有趣的是，在.Net 框架下总算有了一个通用的函数：</p>
<pre>[DllImport(&quot;user32.dll&quot;)]
extern public static int SetWindowText(IntPtr hWnd, string lpString);

</pre><p>如果没有技术的改进，<code>GetProcAddress</code>怕是还会被一群<em>if..else</em>语句包围吧。</p>
<p>所有的函数都有ANSI和Unicode两个版本，但<strong>实际上却都是由Unicode版本来实现</strong>的。这意味着：当你调用<code>SetWindowTextA</code>时，传入一个ANSI字符串，编译器会先将该字符串转换为Unicode字符串，然后调用<code>SetWindowTextW</code>。类似这样的实际操作(设置窗口的标题、内容及名称等)将都由Unicode版本的函数来执行！</p>
<p>再举一个例子，获取窗口内容将用到<code>GetWindowText</code>。你调用<code>GetWindowTextA</code>时，若目的是得到一个ANSI的buffer。<code>GetWindowTextA</code>将先调用<code>GetWindowTextW</code>，并得到一个Unicode字符串(一个<code>wchar_t</code>数组)。然后为你把Unicode字符串转换为ANSI字符串。</p>
<p>ANSI与Unicode互转的操作并不局限于GUI函数，而涵盖了整个Windows API系列中拥有两套方案的字符串处理函数。例如：</p>
<ul>
<li><code>CreateProcess</code></li>
<li><code>GetUserName</code></li>
<li><code>OpenDesktop</code> </li>
<li><code>DeleteFile</code> </li>
<li>etc </li>
</ul>
<p>这就是为何都推荐直接使用Unicode版本函数的原因了。不要仅仅因为多年的习惯，而固守ANSI不放，试着用Unicode来编译吧。但，我们可能还是会去存储或读取ANSI字符串，尤其在某些文件操作和消息传递中。这些转换函数还是有其存在的意义的。</p>
<p><strong>注意</strong>：还有一种常见的定义类型：<strong><code>WCHAR</code></strong>，它等价于<code>wchar_t</code>。</p>
<h2 id="更好的指针表示">更好的指针表示</h2><p><code>TCHAR</code>往往修饰单个字符，当然可以声明一个<code>TCHAR</code>的数组。如果你想表示一个<em>character-pointer</em>或一个<em>const-character-pointer</em>，会用下列哪一个呢？</p>
<pre>// ANSI characters 
foo_ansi(char*); 
foo_ansi(const char*); 
/*const*/ char* pString; 

// Unicode/wide-string 
foo_uni(WCHAR*); 
wchar_t* foo_uni(const WCHAR*); 
/*const*/ WCHAR* pString; 

// Independent 
foo_char(TCHAR*); 
foo_char(const TCHAR*); 
/*const*/ TCHAR* pString;

</pre><p>看过<code>TCHAR</code>的解释，应该会很明确的选择最后一种了吧。那样表示字符串最有效。别忘了引入windows.h头文件。<strong>注意</strong>：如果你的项目直接或间接的引入了windows.h，就不需要引入<code>TCHAR.H</code>了。</p>
<p>首先，再来更好的理解一下老式的字符操作函数，看<code>strlen</code>：</p>
<pre>size_t strlen(const char*);

</pre><p>可以表示为：</p>
<pre>size_t strlen(LPCSTR);

</pre><p><strong><code>LPCSTR</code></strong>符号的定义类型是：</p>
<pre>// Simplified
typedef const char* LPCSTR;

</pre><p>其含义拆解如下：</p>
<ul>
<li><strong>LP</strong> – Long Pointer </li>
<li><strong>C</strong> – Constant </li>
<li><strong>STR</strong> – String </li>
</ul>
<p><code>LPCSTR</code>的本质含义是指向固定字符串的(长)指针。</p>
<p>用新的形式来表述<code>strcpy</code>就是：</p>
<pre>LPSTR strcpy(LPSTR szTarget, LPCSTR szSource);

</pre><p><strong>szTarget</strong>的类型是<code>LPSTR</code>,少了<strong>C</strong>，定义如下：</p>
<pre>typedef char* LPSTR;

</pre><p>注意<strong>szSource</strong>的类型是<code>LPCSTR</code>,<code>strcpy</code>不能改变原字符串，所以要用<code>const</code>限定。返回类型是无const限定的<code>LPSTR</code>。</p>
<p>这些<code>str-</code>函数都是处理ANSI字符串的。但通常我们需要操作双字节字符串，等价的宽字符str函数同样给出了，例如，若计算一个宽字符数组(Unicode字符串)的长度，可以用<strong><code>wcslen</code></strong>：</p>
<pre>size_t nLength;
nLength = wcslen(L&quot;Unicode&quot;);

</pre><p><code>wcslen</code>函数原型：</p>
<pre>size_t wcslen(const wchar_t* szString); // Or WCHAR*

</pre><p>也可以替换为</p>
<pre>size_t wcslen(LPCWSTR szString);

</pre><p>这里的<strong><code>LPCWSTR</code></strong>定义为：</p>
<pre>typedef const WCHAR* LPCWSTR;
// const wchar_t*

</pre><p>拆开来看：</p>
<ul>
<li><strong>LP</strong> - Pointer</li>
<li><strong>C</strong> - Constant</li>
<li><strong>WSTR</strong> - Wide character String</li>
</ul>
<p>类似地，<strong><code>wcscpy</code></strong>与<code>strcpy</code>意义相同，只不过针对的是Unicode字符串：</p>
<pre>wchar_t* wcscpy(wchar_t* szTarget, const wchar_t* szSource)

</pre><p>也可以表现为：</p>
<pre>LPWSTR wcscpy(LPWSTR szTarget, LPCWSTR szSource);

</pre><p>其目标字符串为非常量宽字符串(<code>LPWSTR</code>)，源字符串为常量宽字符串。</p>
<p>存在<code>wcs-</code>函数对应<code>str-</code>函数，前者处理Unicode字符串，后者处理ANSI字符串。</p>
<p>虽然我已经建议过，直接用Unicode的函数替代ANSI与TCHAR的函数。原因很简单，应用程序是必须使用Unicode的，且无须考虑ANSI的兼容性。但出于完整性的考虑，还是继续说明对应的通TCHAR函数吧。</p>
<p>计算字符串长度，可以用<strong><code>_tcslen</code></strong>函数(一个宏)。通常定义如下：</p>
<pre>size_t _tcslen(const TCHAR* szString); 
</pre><p>或
    size_t _tcslen(LPCTSTR szString);</p>
<p>这里的<strong><code>LPCTSTR</code></strong>可分解为：</p>
<ul>
<li>LP - Pointer</li>
<li>C - Constant</li>
<li><strong>T = TCHAR</strong></li>
<li>STR = String</li>
</ul>
<p>根据项目设置，<code>LPCTSTR</code>可以映射为<code>LPCSTR</code>(ANSI)或是<code>LPCWSTR</code>(Unicode)。</p>
<p><strong>注意</strong>: <code>strlen</code>, <code>wcslen</code>或<code>_tcslen</code>返回的是<strong>字符</strong>的个数，而不是所占字节数。</p>
<p>仍是拷贝字符串函数，这里为<strong><code>_tcscpy</code></strong>，定义如下：</p>
<pre>size_t _tcscpy(TCHAR* pTarget, const TCHAR* pSource);
</pre><p>或，更加通用的形式：
    size_t _tcscpy(LPTSTR pTarget, LPCTSTR pSource);</p>
<p>可以推断出<strong><code>LPTSTR</code></strong>的含义了吧！</p>
<h2 id="用法举例：">用法举例：</h2><p>首先，看一个代码片段：</p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">int</span> main()
{
    TCHAR name[] = <span class="string">"Saturn"</span>;
    <span class="keyword">int</span> nLen; <span class="comment">// Or size_t</span>

    lLen = strlen(name);
}</code></pre></div><p>在ANSI字符集下编译完美，因为<code>TCHAR</code>转换为<code>char</code>,因此参数<code>name</code>恰好是<code>char</code>字符数组。
如果在Unicode/_UNICODE被定义(或项目设置了Unicode字符集)的情况下，就会报错：</p>
<pre>error C2440: &#39;initializing&#39; : cannot convert from &#39;const char [7]&#39; to &#39;TCHAR []&#39;
error C2664: &#39;strlen&#39; : cannot convert parameter 1 from &#39;TCHAR []&#39; to &#39;const char *&#39;

</pre><p>对于第一个错误，程序员们开始如此修正了：</p>
<pre>TCHAR name[] = (TCHAR*)&quot;Saturn&quot;;

</pre><p>这不可能好使，因为不可能从<code>TCHAR*</code>转换为<code>TCHAR[7]</code>。同样的错误还会出现在，试图将ANSI字符串作为参数传递给Unicode函数：</p>
<pre>nLen = wcslen(&quot;Saturn&quot;);
// ERROR: cannot convert parameter 1 from &#39;const char [7]&#39; to &#39;const wchar_t *&#39;

</pre><p>不幸的是(或谓之幸运？)，错误可以通过下面这般C风格的类型转换而修正：</p>
<pre>nLen = wcslen((const wchar_t*)&quot;Saturn&quot;);

</pre><p>此刻，你会不会觉得在自己对指针的理解又深入了一层？大错特错！这代码将会返回一个错误的结果，并且大多数情况下，会造成访问冲突。这样的套路，就像是本来需要一个80个字节的结构，却传入了一个<code>float</code>变量(从逻辑上而言)。</p>
<p><strong><code>&quot;Saturn&quot;</code></strong>是一个7字节的顺序序列：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/stringTable.png" alt="stringTable"></p>
<p>但当你把这一套传递给<code>wcslen</code>时，它会将每两个字节看做一个字符，因此，前两位[97,83]将被当做一个值为24915(<code>97&lt;&lt;8 | 83</code>)的字符，在Unicode里是:<code>？</code>。下一个字符则是[117,116]，以此类推。</p>
<p>你的确没有打算把一串中文字符作为参数，但错误的类型转换却干了这事！因此，要深刻的明白强制转换是<strong>祸根</strong>！正确的做法是将第一行改为：</p>
<pre>TCHAR name[] = _T(&quot;Saturn&quot;);

</pre><p>这样源字符串就会根据编译设置，转换为7字节或是14字节。而<code>wcslen</code>函数应该这样使用：</p>
<pre>wcslen(L&quot;Saturn&quot;);

</pre><p>在上述示例代码中，用的是<code>strlen</code>，那在Unicode环境下无法通过编译。错误的解决方法又来了：</p>
<pre>lLen = strlen ((const char*)name);

</pre><p>在Unicode环境下编译，name将占用14字节(7个Unicode字符，包括null)。因为字符串<strong>&quot;Saturn&quot;</strong>仅包含英文字符，所以用的是原生的ASCII来表现。Unicode字符<code>&#39;S&#39;</code>将表现为[83,0],其他字符也都会接上一个零。注意，现在<code>&#39;S&#39;</code>表现为一个值为83的<strong>双字节</strong>字符，字符串的末端也将表现为一个值为<code>0</code>的<strong>双字节</strong>字符。</p>
<p>所以当把这样的一个字符串传递给<code>strlen</code>时，第一个字符(第一个字节)将是正确的(如&quot;Saturn&quot;中的<code>&#39;S&#39;</code>)。但第二个字符/字节将导致字符串的结束。因此，<code>strlen</code>将返回一个错误的值(<code>1</code>)作为字符串的长度。</p>
<p>Unicode字符串是可以包含非英文字符的，那样的结果就是无法预测的了。</p>
<p>简言之，强制类型转换不总是好使的。或者选择用其本身的类型来正确表示，或者对Unicode与ANSI进行常规的转换。</p>
<h2 id="字符数与字节数">字符数与字节数</h2><p>现在，应该可以理解下面的语句了：</p>
<pre>BOOL SetCurrentDirectory( LPCTSTR lpPathName );
DWORD GetCurrentDirectory(DWORD nBufferLength,LPTSTR lpBuffer);

</pre><p>继续说，你肯定见过某些函数/方法中需要传入<strong>字符数</strong>，或是返回字符数吧。譬如<code>GetCurrentDirectory</code>，你需要传入的是字符数，而<strong>不是</strong>字节数。例如：</p>
<pre>TCHAR sCurrentDir[255];

// Pass 255 and not 255*2 
GetCurrentDirectory(sCurrentDir, 255);

</pre><p>而另一方面，如果你需要为数字或字符数组分配空间，则一定要分配整的字节数。在C++中，常使用<code>new</code>关键字：</p>
<pre>LPTSTR pBuffer; // TCHAR* 

pBuffer = new TCHAR[128]; // Allocates 128 or 256 BYTES, depending on compilation.

</pre><p>但如果用的是内存分配函数如<code>malloc</code>,<code>LocalAlloc</code>,<code>GlobalAlloc</code>等等，你必须指定其字节数！</p>
<pre>pBuffer = (TCHAR*) malloc (128 * sizeof(TCHAR) );

</pre><p>这里将返回值强制转换是很有必要的，原因自己领悟。<code>malloc</code>语句内的表达式保证分配了其需要的字节数，并为所要求的字符数分配了空间。</p>
<p><strong> <em>这篇文章翻译自<a href="http://www.codeproject.com/Articles/76252/What-are-TCHAR-WCHAR-LPSTR-LPWSTR-LPCTSTR-etc">What are TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR (etc.)?</a>，由于时间仓促以及水平有限，必然存在某些错误，还请高手指正！</em> </strong></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[《灵异第六感》:生活的注脚]]></title>
        <link href="essay/The-Sixth-Sense"/>
        <published>2010-02-20T18:42:32.000Z</published>
        <updated>2010-02-20T18:42:32.000Z</updated>
        <id>essay/The-Sixth-Sense</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>朋友推荐，说这个电影很经典，说其恐怖之气氛，情节之曲折，难有电影望其项背。更有欧亨利式之结尾。这着实很诱人，垂涎已久后便迫不及待的好好看了一遍。</p>
<p>很喜欢开场的音乐，诡异中透着一股惊悚劲，总是担心什么时候给你来一下。昏黄的灯泡，一闪而灭，沾满灰尘的陈酒瓶底衬着女子脸上丰富的表情变化。一丝寒意莫名而起，恨不得自己都要打个哆嗦。奥莉维亚·威廉姆斯脸上美丽的轮廓，似乎像预兆着什么事情的发生。之后的事情我的确没有预料到，也许是轻柔的音乐掩盖了开局的恐慌？类似《肖申克的救赎》中开头车中的音乐情调。或者是医生脸上的那份柔和？还是夫妻两人一起沉浸在丈夫功绩中的欢乐气氛？但，裸体的陌生男子忽然的出现，只会告诉我那一切只是黑夜降临前黄昏的柔美。这的确提示了我：这是一部惊悚片。</p>
<p>不得不说医生的淡定，要是我，绝不会对着这样一个怪异的陌生者冷静的警告着:“This is 47 Locus Street.”我很难想象我会表现出的恐惧。也许从这一刻起，就注定了恐惧根本不是Malcolm医生的对手。沉稳的眼神下，我知道那是一个男人的成熟。这里其实有一个特别的细节，Malcolm医生看到了赤身男子，首先做的是稳住了爱人，然后便发出那回想起来令人莞尔的警告。也许从这时起我便对这个男子产生了浓厚的兴趣。</p>
<p>但，他很快便倒下了。</p>
<p>他与Vincent的那段对话，令我产生了一丝幻觉：好像令他倒下的不是那一声枪响，而是来自失败的压力。那个市长颁发的金边框奖状代表了生活对医生事业的肯定，而Vincent的出现，便如到达荣誉彼岸的最后一次波浪，狠狠的将医生的帆船打沉。</p>
<p>故事似乎就完了。</p>
<p>我以为医生死了，接下来的情节我一度以为是医生的回忆，但很快，Cole代替了Vincent。原来医生没死？这个疑问随着被屏幕上那个拥有着粉雕玉琢般精致脸庞的小男孩的出现，暂时性的被掩盖住了。这个男孩一身的疑点，为什么要带着父亲的大眼镜，而且还是没有镜片的，为什么他的脸上尽显惶恐的表情。似乎他害怕着什么，又好似躲避着什么。</p>
<p>第一次交谈，他问：What were they hiding from？</p>
<p>也许他希望找到共鸣，也许他只是想知道他的秘密是否已经发生在中世纪的人身上。医生并不知晓，他如往常一样从容，惯性思维直接让他想到了单亲、虐待…</p>
<p>但医生不理解的是那句拉丁文：De profundus clamo adite domine.</p>
<p>这是一句很常用的忏悔句子，医生将翻译好的英文写在纸上:Out of the depths, I cry to you. O Lord!(主啊！我自深渊向你呼唤。)</p>
<p>第二次交谈，他们做了一个游戏，一个猜心的游戏。医生意识到自己的惯性思维的错误，而Cole也渐渐对医生产生了好感。每一次交谈之后，剧情皆会交代双方的家庭——Cole与他的母亲、医生与他的妻子。</p>
<p>Cole的母亲给我的感觉，像是一个很努力却很无力的家庭主妇。面对孩子，她有其坚毅的一面却又时时感到烦躁不堪。尤其是面对Cole的怪异行径——厨房的橱窗瞬间全开、写在纸上的咒骂、照片上若有若无的光痕。</p>
<p>第三次见面，也就是林间小道漫步那一段，医生与Cole给我的感觉便如父子，特别是那句That’s bullshit.更是让我感觉到医生的亲切。他们的心更近了，“Do you know what free association writing is ,Cole？”</p>
<p>医生的家事也出现了问题，结婚周年纪念日的冷淡之餐，“第三者”的出现，一切的一切，似乎指向着医生家庭的破裂。而，医生只是叹了口气，厚重的书上只标注着：“in fact, be self-inflicted.”</p>
<p>课堂那段的确有趣，并不结巴的老师在Cole的不断叫喊中，真的变成了结巴。莫非便是心里暗示么？其实这部影片中心理暗示频频出现，有些是混淆视听的，有些确是很明确教育手段。如我注意到Cole的母亲总是真郑重的重复着一句话，“Hey, look at my face. I was not thinking something bad about you!”也许这便是Cole勇敢地走过小时候的动力所在？</p>
<p>第四次见面貌似是Cole闯了祸，医生坐在他的对面，用“硬币魔术”逗他开心。而医生回到家之际，电视中播放的结婚录像，正是医生对于幸福的怀念。也给我了一个反衬感觉，衬出当下医生的婚姻危机。</p>
<p>也许Cole第一次见到鬼，便是那次party，阁楼上鬼魂的声音响起，而更揪心的是欺负他的同伴竟将他直接丢向了他恐惧的深渊。剧烈的敲击，惊声的尖叫，气球的嘎然破裂，妈妈的无助眼神。我是真的体会到了那句话：“主啊！我自深渊向你呼唤。”</p>
<p>第五次，是床边，医生与Cole坦诚以告。医生透露了自己的家庭烦恼，而Cole则告诉了医生自己的那个秘密。谁也难以置信，医生不外如是。</p>
<p>其中穿插了很多Cole生活的细节，连上厕所都要提心吊胆的Cole着实让人同情，一个不过十多岁的小男孩，却要承受如此大的恐惧，饶是我等成年人，怕也要崩溃。之后各种鬼魂的轮番登场又提示着我这是部惊悚片的事实。</p>
<p>但我真正害怕的是男孩的眼神，淡蓝的恐慌，摇曳的诡异。这一切让我不忍，心灵不堪承受。</p>
<p>之后便是三个人的痛苦，Cole的害怕，伴着红色帐篷里的耶稣与士兵玩具；Cole母亲的担忧，在梦中依旧强烈的想保护儿子；医生的苦恼与犹豫，打碎玻璃的石子，灰心的向Cole告别。种种一切都在第七次见面后发生了改观。</p>
<p>同样在教堂，医生提出了解决方法：面对他们。</p>
<p>很难相信，这么多的恐惧，这么多的烦恼，只有一个方法行之有效，便是勇于面对。于是男孩自此解开了心结——从帮助中毒小女孩翻案开始；母亲解开了心结——原来外婆一直引她为骄傲；医生也终于与妻子在梦中进行了交流——原来妻子一直爱着自己，需要自己。</p>
<p>一切都有了结果。然而医生离奇的发现，自己早已死去，一直存在的只不过是灵魂。</p>
<blockquote>
<p>They don’t see each other, They only see what they wanna see , They don’t know they’re dead.</p>
</blockquote>
<p>谁能预料是这样一个结果，正如我们的生活，结果很难预料。</p>
<p>我深思此电影的寓意，其实Cole遇到的我们每一个人都遇到过，生活中总有很多事情我们不想去面对，如升学考试、亲人的分离、毕业找不到工作的窘境。这些事情便如鬼魂一样，时刻的缠绕着你。正如Cole所说，“Sometimes you feel it inside, like you’re falling down real fast. But you’re really just standing still. You ever feel the prickly things on the back of your neck?”</p>
<p>这些感觉谁也有过，有的人从容的面对——如医生脸上时刻都有的安详，平静。有些人如Cole妈妈那样无助，渴望得到亲人的认可与赞扬。有些人仍然如Cole一样，把自己封在教堂里、红帐中，惶恐不安的度过着每一天，力求寻得庇护。影片中的三个人，多么像一个家庭，成熟稳重负有责任感的医生是爸爸的角色；忙于生活奔波中的Cole母亲，还有在恐惧面前不知所措的Cole。</p>
<p>也许当Cole在舞台上扮演亚瑟王拔出了那柄剑的时候，一个真正的男子汉才真正站立起来。
医生说的对，恐惧害怕并不难对付，勇敢的去面对它就可以了。</p>
<p>只要去面对生活的一切，生活便会给你一个意想不到的结局。医生何曾会想到自己已经死了呢？</p>
<blockquote>
<p>They don’t see each other, They only see what they wanna see , They don’t know they’re dead.</p>
</blockquote>
<p>多么可怕，便如你我，正在人生的路途上追逐，可曾知道自己是否已经死亡？</p>
<p>也有人说，拯救了别人也是成就了自己，医生与Cole便如是。其实永葆一颗从容不迫，敢于面对的心，所有人都会有一个适当的结局。</p>
<p>正如医生知道一切之后的平静：“Good night, sweetheart.”</p>
<p>PS: 请注意一些细节，如Cole妈妈红色的指甲，Cole被抓破的红衣，Cole顺手拿走教堂中的红色耶稣，“被囚”事件中红色的气球，“自由写作”时红色的字迹，毒死女孩一案中凶手的红衣，家中搭建的红色帐篷，教堂通红的大门......</p>
<p>张爱玲素以注重颜色的运用而著名，自是有她的道理，这部影片充斥着如此多的红色，看来在西方人眼中，红色代表着恐惧、压抑之类的含义。</p>
<p>还有一句话特别的好，我分享出来与大家一起深思：</p>
<blockquote>
<p>Sometimes, people think they lose things and they really didn’t lose them…it just gets moved.</p>
</blockquote>
<p>是Cole回应母亲冤枉他偷拿手镯之事时的话，或可为不要患得患失做一个注脚。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[寒假随感——更深入的思考]]></title>
        <link href="essay/hanjiasuigan"/>
        <published>2010-02-01T13:11:42.000Z</published>
        <updated>2010-02-01T13:11:42.000Z</updated>
        <id>essay/hanjiasuigan</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>这个寒假也许是最后一个真正的寒假了吧。</p>
<p>今年都会投入到伟大的考研事业中去，此文也是给休闲并着混乱的寒假画上一个句号，虽然画起来的确费了不少周章。</p>
<p>记得高中语文老师给我们讲起陈寅恪，说为什么老先生晚年会去写《柳如是别传》，这不是不务正业么？时值高三的我们深有同感，作为一个饱读诗书的知识分子，为何不将有限的生命投入到无限的事业中去？却来一个寻花柳巷，以寄幽思？历史老师告诉我们，这是中国文人的通病，这叫无病呻吟！！！而当时语文老师只是说了一句话：“不要怪他，他只是思考的更加深入了。”当时我们并没有把这句话当成一回事，而是马上将注意力投入到紧张的高考复习之中。</p>
<p>三年矣，这句话一直回荡在我的脑海中，中国文人的书生意气一直困扰着积极向上的我。为什么，所有的我钟爱的词曲，都会带有淡淡的哀思；为什么屈原一部楚辞，竟是处处泪水；司马迁一部史记，不颂成王，却哭败寇？难道只是怜悯？难道只是悲天悯人？这份若有若无的哀愁，竟是那么的美，说不清楚的美，只在我每每掩卷叹息之际萦绕心间。以前是说不清道不明，而随着时光的洗涤，我的心灵更多的感受到了这份美感。就在我读了《柳如是别传》前几章之后，泪水止不住的往下流，书生意气的苦痛又有几人知晓？</p>
<p>高中时期一个年迈的物理老师曾提及牛顿的晚年，一世英名的牛顿为何在晚年将精神完全寄托于上帝？这难道不是一种对其事业及成就的讽刺么？老师只是默默的叹息，“他只是有了更深的思考。”
这两位老师的答案惊人的相似，时过境迁，也许原话我已记不清楚。但这两句几乎相同的话震荡了我的心弦。什么是更深的思考？</p>
<p>这让我想起了孔子说子张，“子贡问：‘师与商也孰贤？’子曰：‘师也过，商也不及。’曰：‘然则师愈与？’子曰：‘过犹不及’。”我认为无论是陈寅恪还是牛顿，都无可避免的犯了同一个错误，便是这过犹不及。</p>
<p>其实这么说是很片面的。分别来说，陈寅恪是逃避现实的压力，牛顿是逃避科学未解的压力。同样是压力，酿成了悲剧。我所说的那种美，便是这悲剧之美。一些文人看似疯狂的举动或者是不正常的言论，其必有其深刻原因。而这种原因的造成便是压力，现实的压力，精神迫于现实的反差。而这压力何由来？便是过犹不及造成的。</p>
<p>孔子虽然知道过犹不及，然而其自己也难免深陷其中，其所提倡的中庸之道便是在这过与不及之间寻求一种平衡。一旦平衡打破，便总是不谐。知其不可而为之，不也是一种过么？释家所言的执念，不也是一种过么？道家倡导的无为而治不仍旧是一种过吗？</p>
<p>便是因为这总总学说找不到那个神秘的平衡，于是才有此总总之过。而这个平衡，在儒家是仁，在道家是道，在佛家是无。为什么我们总是解释不清楚这些深刻意义的名词，是因为我们也无能为力，我们永远只是在探索，永远也达不到那份完美。</p>
<p>而书生意气，正是那种无能为力的忧愁，明知真理在前方，却不知道通往之路在何处？鲁迅说，人生最大的悲哀是梦醒了，却不知道路在何处。人类的能力总是渺小的，没有人可以做到绝对的完美。那些为之奋斗的战士心中便有了忧郁，便时时刻刻的担忧，心中的抑郁无法排解，便有了这许许多多我们无法理解的东西。如《柳如是别传》，如上帝之手。不要怪他们，他们的苦痛，只有你也“过”的时候，才会深深的明白。</p>
<p>这是人之常情，子贡不也本能的认为“然则师愈与”么。子张便是那个战士，当他发现他苦苦的探索，艰难的奋斗之后，仍旧达不到那完美境界。心中的失落必然有之，然发现自己做了这么多，其实和还没做多少的子夏是同一水平之时，心中那份不平谁又能体会？以上解释我仍觉得片面，也许我也“过”了吧。</p>
<p>难为了那些以为路在前方的战士们，他们上下求索，积极探索。其实，他们往往已经错过了真正的路。</p>
<p>这是人性的伟大，却也是人性的悲哀。</p>
<p>我本人而言，也应该掌握这个度，凡事想的过了也许恰恰错过了真理。苦苦的坚持，也许只是一种无谓的自讨苦吃。但，同时我也为我的“过”而自豪，因为这恰恰说明我是个活生生的人。</p>
<p>这个句号也许画的并不圆满，我也无法言尽我对于那些真正的知识分子的敬畏。无法言尽我对精神生活的思索。更没能说明我个人的未来的去向，将来的发展。</p>
<p>但也许一切只在不言中。</p>
<p>感谢鲁枢元的《精神守望》，钱穆的《中国历史研究法》，陈寅恪的《柳如是别传》，司马迁的《史记》。感谢你们教会我的，那是我一辈子也难以割舍的情怀。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[人性的虚妄]]></title>
        <link href="essay/renxingdexuwang"/>
        <published>2008-12-26T15:50:00.000Z</published>
        <updated>2008-12-26T15:50:00.000Z</updated>
        <id>essay/renxingdexuwang</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>人生是一场虚妄的盛宴。</p>
<p>我们有多少生命为虚荣而绽放，有多少时间为空虚而燃烧？</p>
<p>我便是一个虚伪的人，虚荣的要求这着一切，不管那是否属于我。我的人生是虚伪中的虚伪，真实已被这虚伪吞噬。</p>
<p>人性的荒原，那里很远，请不要在意那些流浪的灵魂，他们的精神已被放逐，留下的只是虚空的留恋。</p>
<p>十有八九，真真假假，无处不再，务实空话。</p>
<p>华美的年华，因这些虚妄而匆匆流逝，貌美的青春，因这些虚妄而怅然若失。我想刺杀此虚妄，以我今生之力，用我结实的拳头，将它击的粉碎！</p>
<p>皓首穷经，一头白发只为一朝虚名，子云：“好知者不如乐知者。”借问，天下乐之者几何？</p>
<p>子曰：“述而不作。”错错错，不作天下何以闻？述又几人听？述于心，作与不作何异？</p>
<p>“岁寒，知松柏而后凋也！”荒原白雪皑皑，松柏难在，岁寒而易，人生如戏。</p>
<p>若说黄粱一梦是一生，甩手辞世，又有何事留恋？虚无之物，何必在乎？我不信此黄粱，人生终有留下之物，发乎于心，系于肺腑，虽死千年，犹存世间。此即非虚妄之于希望也。</p>
<p>一个真字，世人难事，此为之本，却寻逐末。无真之美，谓之虚容，无真之善，是为伪善。希望之于虚妄，在此真也。人生如梦乎？如梦之虚乎？乏真也。</p>
<p>天降虚妄与世间，人遂分，纵使靓丽如虹，犹在空中，追之一生，岂不若夸父追日？可得乎？不若沐于虹彩，迎千里凉风，大道快哉！</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[荒原]]></title>
        <link href="essay/huangyuan"/>
        <published>2008-12-25T15:50:00.000Z</published>
        <updated>2008-12-25T15:50:00.000Z</updated>
        <id>essay/huangyuan</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>我只愿不语，因为我的忧伤属于上古。</p>
<p>寂寞的荒原，四周只有我的心语。孤星黯照天际，只让明月妒忌，银河见证我的疯狂，绝望的在黑夜寻找太阳。</p>
<p>我只愿不语，因为我的言论戳破了语言的漏洞，只因为此因为，语言负我，千夫口指。</p>
<p>我只愿不语，因为我语言随心所欲，但对不起，它逾矩。</p>
<p>心思诡谲，孰人能破，千古思索，岂能言尽。</p>
<p>在此荒原，我独与天语，在病态中病态，是无奈的无奈。</p>
<p>在此荒原，言只由衷，语言不需阶梯，我不愿去眺望那天上的美丽。</p>
<p>立，指天，指地，指你。</p>
<p>荒原有野草，千里烂漫，视觉直接的感受，唯凭心灵。</p>
<p>中文若是太过服从逻辑，是向英文屈膝。</p>
<p>蜈蚣千足，一句中文何似此？缠绵难奈，字字句句若相爱？</p>
<p>还好，有此荒原，愿与我共舞，何言孤独，天地共睹。放眼野草遍处，模仿一世，到头来千年一叹：吾不如电脑乎？</p>
<p>在此荒原，没有杂色的文字滋长，没别的，我心不让。誰言好文定配好人，我白眼相向，愿在荒原苟存。</p>
<p>一句比一心，一改心难鸣，心境翻手云，改过不再清。</p>
<p>我宁愿口齿不清，但愿此情言明，中文在意达，快餐不可闻。</p>
<p>荒原有其人，三改其文，我游历于其中，其中以非昨日江湖。完美之于虚妄，与狂想视为一物。一人狂想症，数亿江湖浊。子曰：“夫我则不暇”。</p>
<p>犹记南山隐士，疑义相与析，再看荒原外，奇文作粪吞。文与钱相连，至贱不可闻，文与利合璧，和氏复哭泣。谁解其中意，恣意解酒去！</p>
<p>子曰：“攻乎异端，斯害也已”。文亦有异，老者点头，少者漂流，海角乎天涯，江湖兮摆手。</p>
<p>异文有巧心，旖旎不可闻，只可置荒原，为人何以放逐魂？</p>
<p>西方人有脑，中国人有心，此脑乍看如蛆堆，此心玲珑且七窍。有心不用，执蛆骄傲，盛赞“斯为美”！借问，“为之奈何”？</p>
<p>可崩之文却靠挤，说文却像茅厕意，“善哉善哉”，“罢矣罢矣”！</p>
<p>或曰：“荒原种些花草，也是好的。”曰“然”。</p>
<p>心中不泯的童话，“那精神花园，愿繁花似锦。”今日相伴，却唯剩荒原。</p>
<p>人性的荒原，神被放逐了，去那遥远的西方，留学去了。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[山水]]></title>
        <link href="essay/shanshui"/>
        <published>2008-12-20T15:50:00.000Z</published>
        <updated>2008-12-20T15:50:00.000Z</updated>
        <id>essay/shanshui</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>有这么一幅山水画，在中华大地上躺着，已经五千年了，尽是些儿女的墨彩。最底下的那层，散发着浓浓的黄土味道，今日却已淡了；本是很妙的水墨丹青，今也有了些油画的味道。我走过这片山水，静静的沉浸于其中，享受着那股古典的气息，悠悠于南山下，飘飘乎长江边，听黄河水浪打浪，看长城外山连山。这水，那山，似乎都印上了什么符号般，我达达的马蹄声，竟是它们冥冥中的知音。行走在中华大地上，我使劲的嗅着那淡雅的墨香，夹杂的，还有那百年老窖的醇香，更有那清雅的茶香，它们不自觉的弥漫在这片土地上，恣意而烂漫着。这里的人们，千年来都在这幅巨画上涂抹勾勒着，笔锋时而转淡轻描，时而泼洒浓意，时而九曲一回肠，时而伏笔千百处。纵使有无数的天灾与人祸，这幅画仍是任谁也撼动不了，如此多难，反而成就了这幅画的厚度。厚得顶住了炮弹与硝烟，使如今能几近完整的呈现在我们的眼前。</p>
<p>我只是这幅山水画边的观赏者，踱步于其中，醉心于每一笔勾勒，每一点浓淡，我早已梦入其中，不可自拔了。</p>
<p>这是一场美妙的盛宴，我所能撰写下的，只是些残羹。需要一个个味蕾极佳的舌头，去回味它。这样，我们才能在这幅画上继续的画下去。</p>
<p>谨记这片山水......</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[睡前小感]]></title>
        <link href="life/shuiqianxiaogan"/>
        <published>2008-10-20T15:20:00.000Z</published>
        <updated>2008-10-20T15:20:00.000Z</updated>
        <id>life/shuiqianxiaogan</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>主要是很郁闷，否则也不会没事在睡前乱感了，睡觉前想东西毕竟是很不爽的一件事。</p>
<p>这郁闷的便是这辩论赛的事。</p>
<p>我就不明白了，为什么我所在的队就没有一次赢呢？一年前我参赛是这样，现在我带队还是这样，怎么有种被诅咒的感觉呢？唉，真是惭愧啊，我被诅咒不要紧，这些跟我合作的兄弟们呐，惨啊，胜利就像一场盛宴，我们却连残羹也没搭上。要说没准备吗？今天打得这场我可是下了心血的啊，准备的也很充分了，该给队员说的也说了，哪怎么答，哪怎么问，我也说了很多遍了，为什么一上场就完全不是我想象的那个样子呢？我也是那么多时间，别人也是那么多时间，为什么我带的队就是输，为什么就不能让我赢一次呢？</p>
<p>总之，我是有阴影了，再让我带队我是绝对不干了，还是埋头学习好了，并不是我受不了打击，我是不想再祸害无辜的群众了。</p>
<p>遥想不才当年，刚入大学时，是四辩，参加系里的比赛一共有两场，一次代表本班，输了，没感觉；一次代表混合队，队友实力大大增强了，又输了，感觉微痛，无关大碍。后入系队，就算是陪练，还是把主队祸害了，首轮便被淘汰的惨痛事实，今日仍不能释怀。当时心灰意冷，暗暗发誓今生不提辩论二字，竟不想一年之后，学生会以其擅长的强迫方式又让我忍痛回首，重赴东山。第一次我并没在意，敷衍了事，惨败也情有可原，第二次我知耻而后勇，奋力的担当，企图力挽狂澜，背水一战后，竟是全军覆没。无语，不服，力竭，认命。</p>
<p>嗨，本人过错，却伤了08级学弟学妹的心，年轻的心就要这样背负失败的阴影，人家鲁迅先生是肩住黑暗的闸门，放孩子们到光明的地方去，我却是以为能肩住黑暗的闸门，没想到孩子们都被放到黑暗中去了。</p>
<p>“牢骚太盛防肠断”，就感这么多，睡了......</p>
<blockquote>
<p>PS:貌似这睡前小感也需要功夫啊，困的我......</p>
</blockquote>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[《论语》管仲之论究武侠之本]]></title>
        <link href="essay/lunyu"/>
        <published>2008-10-20T15:20:00.000Z</published>
        <updated>2008-10-20T15:20:00.000Z</updated>
        <id>essay/lunyu</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>一次选修课上，老师忽然提到了孔子对管仲评价的问题，我那原本昏沉的大脑忽然的活跃起来。这个问题我也思考已久，但却不成系统，近日研究武侠之心未减，正好给了我一种貌似离奇的想法：武侠之本意与来源谁也讲不清楚，但从《论语》管仲之论中，或许可以找到一丝线索。</p>
<p>说到管仲之论，孔子的态度，在表面上看似乎有些自相矛盾。如八佾第三中有此一段：</p>
<blockquote>
<p>子曰：“管仲之器小哉。”</p>
<p>或曰：“管仲俭乎？”</p>
<p>曰：“管氏有三归，官事不摄，焉得俭？”</p>
<p>“然则管仲知礼乎？”</p>
<p>曰：“邦君树塞门，管氏亦树塞门。邦君为两君之好，有反坫，管氏亦有反坫。管氏而知礼，孰不知礼？”</p>
</blockquote>
<p>一句“管仲之器小哉”道出了孔子对管仲的基本态度。何谓“器小”？《朱注》曰：器小，言其不知圣贤大学之道，故局量褊浅，规模卑狭，不能正身修德，以致主于王道。儒家讲究内圣外王，颜回曾参是内圣的代表，而子张子夏则是外王的先祖。管仲之器小，俗话讲，就是说他修身养性的功夫没做足，不符合孔门内圣的标准。于是继而又问其知礼否，孔子的态度可以说是极其的鄙视了，树塞门、反坫皆是邦君之礼，而管仲用的倒是得心顺手。这种越礼的行为是孔子最为反感的，于是语言也尤为强烈，“八佾舞于庭，是可忍也，孰不可忍也？”“‘相维辟公，天子穆穆’，奚取于三家之堂？”此类言语数不胜数。在管仲身上，孔老夫子也很不留情面，“管氏而知礼，孰不知礼？”这样看来，我们很容易相信孔子是绝不会称这样的人为仁的。但事实却正好相反，一向豪爽义气的子路便看不惯管仲的为人，宪问第十四中有此一段：</p>
<blockquote>
<p>子路曰：“桓公杀公子纠，召忽死之，管仲不死。”</p>
<p>曰：“未仁乎！”</p>
<p>子曰：“桓公九合诸侯，不以兵车，管仲之力也。如其仁，如其仁。”</p>
</blockquote>
<p>召忽与管仲同为公子纠之臣，而当公子纠死时，两人却有不同的行为，召忽选择了以死言忠，管仲不但不死，反而投靠了桓公（即公子小白）。这样的行径是讲究忠孝的儒家所不容的，于是子路愤愤不平：“未仁乎！”而孔子的回答却让当年初读的我大跌眼镜，“如其仁，如其仁。”对比先前的八佾篇，孔夫子似乎有些自相矛盾，但深究之下，其实不然。</p>
<p>八佾篇中孔子不满的是管仲的不知礼，毫无内圣之德。而在宪问篇中赞扬的是管仲的如其仁。一个不知礼之人难道便难成仁了么？难道在孔子的思想里，礼和仁并不是完全统一的么？</p>
<p>这里我们无疑要解决礼与仁这两大儒学思想核心的区别和联系。在我看来，孔子思想的核心在仁，而礼只是一种实现仁的手段。可以说“仁”亦“人”也，而“礼”亦“例”也。即孔子宣扬的是一种人与人的学说，这也是我们中华民族文化内涵的核心。不同于西方文化中所注重的人与自然的关系，中国人更加着眼于现实生活，在中国人眼里，现实生活中人与人之间的关系远比人与自然的关系重要和亲切的多。中华民族是个务实的民族，当西方人将眼睛投向未来与天堂的时候，中国人正紧盯着今生与现世。这也是为什么工业革命出现在西方而不在中国的原因。儒家学派也正是处处着眼于今生，论语二十篇，篇篇从日常生活讲起。人，这个生活中重要的元素无疑是儒家所要研究的大学问，而礼正是承自远古商周的历代经验。子曰：“温故而知新，可以为师矣。”故往圣之成礼，便为孔子终生所重视。究其本源，礼者，先王之惯例也，中国人注重过去，故先王之惯例在人们心中是有广泛认同的，可以说是有很坚实的群众基础的。所以，孔子是集此等惯例为一体，从中抽象概括出“礼”这么个东西来的。触类旁通，孔子说“君君，臣臣，父父，子子。”并不是要强调王权至高无上，他更多的是尊重这个承自商周的惯例，尊重这个完整的制度。而这里的制度，便是孔子所推崇之礼的一个具体表现。在这里，我们不禁要问，孔子为什么这样极力的推崇这些惯例和制度呢？难道只是为了传承吗？于是，我们又要回到儒学的核心“仁”上来。我要说，仁是一副躯体，而礼则是披于其上的外衣。孔子数赞礼之美：“绘事后素”、“焕然其有文章”。孔子是乐于礼的，“从心所欲，不逾矩”，这“矩”便是礼制了。所以我们可以说，礼是为仁而服务的，赤裸裸的东西都不好看，也很难理解，连子贡也说，“夫子之文章，可得而闻也；夫子之言性与天道，不可得而闻也。”这里的性与天道，便是孔子之仁。仁是不可得而闻的，便是得了也是不叫人喜欢的。说到这里，也就豁然贯通了。有如管仲之仁，便是那种赤裸裸的仁，没有礼的包装，难怪子路会看不过去，何止子路，崇礼的孔门弟子，谁又会对此表认同之态呢？同是宪问篇，子贡也同样有所疑问：</p>
<blockquote>
<p>子贡曰：“管仲非仁者与？桓公杀公子纠，不能死，又相之。”</p>
<p>子曰：“管仲相桓公，霸诸侯，一匡天下，民到于今受其赐。微管仲，吾其被发左衽矣。岂若匹夫匹妇之为谅也，自经于沟渎，而莫之知也？”</p>
</blockquote>
<p>此段孔子更是明白的说出了管仲为仁的理由，“岂若匹夫匹妇之为谅也”管仲是取大仁而不计小仁的。如果当初管仲为成其小仁，而“自经于沟渎”，也许真的会“吾其被发左衽矣”。由此观之，孔子之仁，是一种眼界高远，不拘细谨的大仁。这里也体现了儒家文化博大的胸襟，而非常人可以看清和理解的。后世有如管仲之人，多如牛毛，李斯曹操之辈数不胜数，我们冠之以“枭雄”是也。这些枭雄，多是无视礼法之辈，人品也常为人所不齿，但孔子却称此类人为仁。相比之下，程朱理学之徒的死板与拘泥真是未得儒学之真谛。</p>
<p>这便是《论语》中的管仲之论，而这与武侠相去甚远，怎可相提并论呢？</p>
<p>我们暂不提《论语》，只想想武侠为什么会在民间流传深远，难道只是一种出于半殖民地特有的身体狂想吗？那试问明清一代的武侠为什么也有如此吸引力呢？韩子有云：“儒以文乱法，而侠以武犯禁。”这本是讥二者之语，但这有意无意的把儒与侠放在一起，便引起了中国文人千年的遐想。上至侠义小说，下至金庸古龙，那些大侠们无不是披着“侠”之外套，大行“儒”者之事。想法虽都是狂妄了些，但无不是出自儒家的理念。反观管仲之论，我们似乎忽略了两位引发者——子路与子贡。通读《论语》之人，便可知此二人的可爱，还有一位有个性的宰我，让人过目难忘。子路可爱在他的直率与忠勇，他可以说是武侠的鼻祖，明清至今，侠者身上皆有他的影子。他们既有暴虎冯河之勇，又有儒家仁德之智。他们“愿车马衣轻裘与朋友共敝之而无憾”。他们较“枭雄”者可亲，较腐儒者可爱，较当权者可信。他们为人们所接受，并不是他们身怀绝技使人羡慕，而是他们身上那种“仁”的文化让人心中温暖。什么是行侠仗义？具体地说，便是仁者爱人的具体表现。什么是生死义气？换句话说，就是重然诺轻生死。说侠之大者，为国为民。但转念一想，真正为国为民的是这些大侠吗？变法振秦之商鞅，千古留名之王安石，他们哪一位是走江湖的侠客？反之，真正为国为民的伟人们似乎也无法让人称之为侠，从董仲舒以春秋决狱，到张居正居丧夺情，此等不知礼数之辈，何以担当“侠”之一字。所谓的侠，不过是将在“枭雄”身上的礼与仁的矛盾与冲突和解统一罢了，不过是一种对道德绝对完美的一种追求与幻想罢了。武侠，素有成年人童话之称。不以完美之态呈现在群众面前，孰人观之？假想管仲若在武侠世界，必会欲以死殉道，却又被离奇相救，终成桓公大业。此类情节在武侠里遍处可寻。大侠永远是以大义为先——这是外套，永远是以小仁居多——这是实体。武侠是大众文化，这便决定了它一定要强调小仁，如那为公子纠而殉身的召忽便是一代大侠风范，他如此作为，似乎只为让人们一声唉叹，一声赞美，一声惋惜。人们钦佩这种重然诺的侠士，越是不易做但应该做的事被人做了，这个人便是值得尊敬的，它的存在，补充了人们心中完美道德的空缺，这是将一种美好的虚妄，来填补人们心中假象的希望，这希望正是不信宗教不信鬼神的中国人顽强存活的精神信念。武侠风靡中国几百年，意义应在于此，其本应源于此。</p>
<p>同是仁，大仁见之以礼，小仁见之以侠。礼为其大，社会制度得以健全；侠为其小，大众精神得以温存。细查管仲之论，叹孔圣之深远宽广，爱赐由之侠义心肠。行仁至悲壮，有孔圣知其不可而为之；行侠至悲壮，有荆轲临行之易水孤寒。同样让人心之戚戚，同样让人千年长叹。</p>
<p>小议一句：窃以为子路为武侠之祖，子贡为智侠之宗。</p>
<p>以儒者入侠客，大有不敬，但求其深层之联系，妄自为之。愿求有幸得陈司败者，畅言吾之过也！</p>
]]>
        </content>
    </entry>
</feed>
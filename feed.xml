<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>pezy's blog</title>
    <link href="feed.xml" rel="self" />
    <link href="" />
    <id>feed.xml</id>
    <entry>
        <title type="html"><![CDATA[使用八叉树算法管理场景对象(用OpenSceneGraph实现)]]></title>
        <link href="study/octree-note"/>
        <published>2014-09-15T00:00:00.000Z</published>
        <updated>2014-09-15T00:00:00.000Z</updated>
        <id>study/octree-note</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <blockquote>
<p>声明: 本文翻译自<a href="http://t.cn/Rhi9Dj7">OpenSceneGraph 3 Cookbook</a>中的Chapter 8某小节, 更多内容请购买该书查看.
以下内容仅供学习之用, 禁止转载. 如有翻译错误之处, 请通过评论告之.</p>
</blockquote>
<p>在最后一个章节, 我们花了大量的时间讨论VPB地形模型的结构, 并且已经对四叉树场景图比较熟悉了.
在LOD和paged LOD的帮助下, 我们可以用四叉树算法快速地管理地形板块, 无限制的渲染地形数据.
事实上, 许多其他的应用也在处理海量数据时, 选用四叉树来管理场景, 例如城市建筑, 人群, 网络拓扑等.
一个四叉树的内部节点恰好包含四个子节点, 所以它非常擅长管理XOY平面上的对象.</p>
<p>那么如果我们要分割的是三维空间, 该怎么做呢? 例如, 如果我们有大量的球体随机的分布在三维空间里,
应该使用一种高效的空间索引算法来管理它们呢? 有一种解决方案叫做<strong>八叉树</strong>. 这是另一种树状结构,
其内部节点(3D区域)恰好有八个子区域, 如下图所示:</p>
<p><img src="octree_note/octree.png" alt=""></p>
<p>VPB使用一个二维的四叉树来组织地形, 类似的我们可以使用三维的八叉树来组织体数据或复杂场景(例如太阳系中的大量行星).
在这个方案中, 我们将使用LOD节点来构造这样一个八叉树结构, 来渲染海量的球体元素. 这些球体将大小不一的随机分布在三维空间里.</p>
<h2 id="实例剖析">实例剖析</h2><ol>
<li>引入必要的头文件<div class="highlight"><pre><code class="cpp"><span class="preprocessor">#include &lt;osg/PolygonMode&gt;</span>
<span class="preprocessor">#include &lt;osg/ShapeDrawable&gt;</span>
<span class="preprocessor">#include &lt;osg/Geometry&gt;</span>
<span class="preprocessor">#include &lt;osg/Geode&gt;</span>
<span class="preprocessor">#include &lt;osg/LOD&gt;</span>
<span class="preprocessor">#include &lt;osgDB/ReadFile&gt;</span>
<span class="preprocessor">#include &lt;osgUtil/PrintVisitor&gt;</span>
<span class="preprocessor">#include &lt;osgViewer/ViewerEventHandlers&gt;</span>
<span class="preprocessor">#include &lt;osgViewer/Viewer&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span></code></pre></div></li>
<li>首先声明一个<code>OctreeBuilder</code>类, 它将使用<strong>八叉树</strong>算法来构造一个场景图.
使用<code>setMaxChildNumber()</code>方法设定一个叶子节点中包含多少个geometries(默认为16个).
使用<code>setMaxTreeDepth()</code>方法设定八叉树最大层次数目(默认为32个).<div class="highlight"><pre><code class="cpp"><span class="keyword">class</span> OctreeBuilder
{
<span class="keyword">public</span>:
    OctreeBuilder() : _maxChildNumber(<span class="number">16</span>), _maxTreeDepth(<span class="number">32</span>), _maxLevel(<span class="number">0</span>) {}
    <span class="keyword">int</span> getMaxLevel() <span class="keyword">const</span> { <span class="keyword">return</span> _maxLevel; }
    <span class="keyword">void</span> setMaxChildNumber( <span class="keyword">int</span> max ) { _maxChildNumber= max; }
    <span class="keyword">int</span> getMaxChildNumber() <span class="keyword">const</span> { <span class="keyword">return</span> _maxChildNumber; }
    <span class="keyword">void</span> setMaxTreeDepth( <span class="keyword">int</span> max ) { _maxTreeDepth = max; }
    <span class="keyword">int</span> getMaxTreeDepth() <span class="keyword">const</span> { <span class="keyword">return</span> _maxTreeDepth; }
    <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, osg::BoundingBox&gt; ElementInfo;
    osg::Group* build( <span class="keyword">int</span> depth, <span class="keyword">const</span> osg::BoundingBox&amp; total,
      <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;ElementInfo&gt;</span>&amp; elements );
<span class="keyword">protected</span>:
    osg::LOD* createNewLevel(<span class="keyword">int</span> level, <span class="keyword">const</span> osg::Vec3&amp; center, <span class="keyword">float</span> radius);
    osg::Node* createElement(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; id, <span class="keyword">const</span> osg::Vec3&amp; center,
      <span class="keyword">float</span> radius );
    osg::Geode* createBoxForDebug(<span class="keyword">const</span> osg::Vec3&amp; max, <span class="keyword">const</span> osg::Vec3&amp; min);
    <span class="keyword">int</span> _maxChildNumber;
    <span class="keyword">int</span> _maxTreeDepth;
    <span class="keyword">int</span> _maxLevel;
};</code></pre></div></li>
<li><code>build()</code>方法将被递归的调用, 来创建八叉树的每一层级. 调用时可以将深度设为0, total指定为包围球,
elementes包含巨大场景中的全部元素.<div class="highlight"><pre><code class="cpp">osg::Group* OctreeBuilder::build(<span class="keyword">int</span> depth, <span class="keyword">const</span> osg::BoundingBox&amp; total,
    <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;ElementInfo&gt;</span>&amp; elements)
{
    ...
}</code></pre></div></li>
<li>我们用两个长度为3的数组来计算区域的基本属性. <code>s[]</code>表示八叉树每一个层次的全部八个元件. 数组中的值只能为0或1,
用此来描述每个元件是在X/Y/Z三个轴的左边还是右边. <code>extentSet[]</code> 记录了这个层次区域的最小, 中间, 最大的点坐标,
它后续将用来计算其孩子节点的区域.<div class="highlight"><pre><code class="cpp"><span class="keyword">int</span> s[<span class="number">3</span>]; <span class="comment">// axis sides (0 or 1)</span>
osg::Vec3 extentSet[<span class="number">3</span>] = {
    total._min,
    (total._max + total._min) * <span class="number">0.5f</span>,
    total._max
};</code></pre></div></li>
<li><code>elements</code>包含了场景中的全部元素, 因此我们可以找出那些在当前区域<code>total</code>中, 并将它们存储在一个临时列表(<code>childData</code>)里.
如果当前区域的元素少到仅能组成一个叶子节点, 将<code>isLeafNode</code>设为true. 否则设为false, 以继续将区域细分为下一个层次的8个子节点.<div class="highlight"><pre><code class="cpp"><span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;ElementInfo&gt;</span> childData;
<span class="keyword">for</span> ( <span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;elements.size(); ++i )
{
    <span class="keyword">const</span> ElementInfo&amp; obj = elements[i];
    <span class="keyword">if</span> ( total.contains(obj.second._min) &amp;&amp; total.contains(obj.second._max) )
        childData.push_back( obj );
    <span class="keyword">else</span> <span class="keyword">if</span> ( total.intersects(obj.second) )
    {
      osg::Vec3 center = (obj.second._max + obj.second._min) * <span class="number">0.5f</span>;
      <span class="keyword">if</span> ( total.contains(center) )
        childData.push_back( obj );
    }
}
<span class="keyword">bool</span> isLeafNode = <span class="keyword">false</span>;
<span class="keyword">if</span> ( (<span class="keyword">int</span>)childData.size()&lt;=_maxChildNumber || depth&gt;_maxTreeDepth )
    isLeafNode = <span class="keyword">true</span>;
osg::ref_ptr&lt;osg::Group&gt; group = <span class="keyword">new</span> osg::Group;
<span class="keyword">if</span> ( !isLeafNode )
{
    ...
}
<span class="keyword">else</span>
{
    ...
}</code></pre></div></li>
<li>如果<code>isLeafNode</code>为假, 我们将不得不建立包含了八个新的子区域的下一层次区域盒.
这些子区域使用<code>osg::Group</code>创建, 并加到父节点中. <code>build</code>方法将通过不同的区域参数被递归地调用,
用以检查和建立子图.<div class="highlight"><pre><code class="cpp">osg::ref_ptr&lt;osg::Group&gt; childNodes[<span class="number">8</span>];
<span class="keyword">for</span> ( s[<span class="number">0</span>]=<span class="number">0</span>; s[<span class="number">0</span>]&lt;<span class="number">2</span>; ++s[<span class="number">0</span>] )
{
    <span class="keyword">for</span> ( s[<span class="number">1</span>]=<span class="number">0</span>; s[<span class="number">1</span>]&lt;<span class="number">2</span>; ++s[<span class="number">1</span>] )
    {
      <span class="keyword">for</span> ( s[<span class="number">2</span>]=<span class="number">0</span>; s[<span class="number">2</span>]&lt;<span class="number">2</span>; ++s[<span class="number">2</span>] )
      {
        osg::Vec3 min, max;
        <span class="keyword">for</span> ( <span class="keyword">int</span> a=<span class="number">0</span>; a&lt;<span class="number">3</span>; ++a )
        {
          min[a] = (extentSet[s[a] + <span class="number">0</span>])[a];
          max[a] = (extentSet[s[a] + <span class="number">1</span>])[a];
        }
        <span class="keyword">int</span> id = s[<span class="number">0</span>] + (<span class="number">2</span> * s[<span class="number">1</span>]) + (<span class="number">4</span> * s[<span class="number">2</span>]);
          childNodes[id] = build(depth+<span class="number">1</span>, osg::BoundingBox(min, max), childData);
      }
    }
}
<span class="keyword">for</span> ( <span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i )
{
    <span class="keyword">if</span> (childNodes[i] &amp;&amp; childNodes[i]-&gt;getNumChildren())
      group-&gt;addChild( childNodes[i] );
}</code></pre></div></li>
<li>如果当前节点可作为八叉树中的叶子节点, 我们只要调用<code>createElement()</code>来生成球体并设置一些必要的参数来渲染它.
这些可渲染的元素将被加到<code>osg::Group</code>中, 用以呈现八叉树的叶子节点.<div class="highlight"><pre><code class="cpp"><span class="keyword">for</span> ( <span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;childData.size(); ++i )
{
    <span class="keyword">const</span> ElementInfo&amp; obj = childData[i];
    osg::Vec3 center = (obj.second._max + obj.second._min) * <span class="number">0.5</span>;
    <span class="keyword">float</span> radius = (obj.second._max - obj.second._min).length() * <span class="number">0.5f</span>;
    group-&gt;addChild(createElement(obj.first, center, radius));
}</code></pre></div></li>
<li><code>build()</code>方法的最后一个步骤, 是使用<code>osg::LOD</code>来完成当前层次的构建. 当视线远离场景时,
它包含一个示意盒(或什么也没有)来粗略表示. 只有视线足够靠近, 才会既包含八个子节点, 又包含一些叶子节点.
其中将出现少量的球体, 这取决于<code>_maxChildNumber</code>的值了.<div class="highlight"><pre><code class="cpp">osg::Vec3 center = (total._max + total._min) * <span class="number">0.5</span>;
<span class="keyword">float</span> radius = (total._max - total._min).length() * <span class="number">0.5f</span>;
osg::LOD* level = createNewLevel( depth, center, radius );
<span class="comment">// For debug use</span>
level-&gt;insertChild( <span class="number">0</span>, createBoxForDebug(total._max, total._min) );
level-&gt;insertChild( <span class="number">1</span>, group.get() );
<span class="keyword">return</span> level;</code></pre></div></li>
<li><code>createNewLevel()</code>方法用于创建自定义LOD节点.<div class="highlight"><pre><code class="cpp">osg::LOD* OctreeBuilder::createNewLevel( <span class="keyword">int</span> level, <span class="keyword">const</span>
    osg::Vec3&amp; center, <span class="keyword">float</span> radius )
{
    osg::ref_ptr&lt;osg::LOD&gt; lod = <span class="keyword">new</span> osg::LOD;
    lod-&gt;setCenterMode( osg::LOD::USER_DEFINED_CENTER );
    lod-&gt;setCenter( center );
    lod-&gt;setRadius( radius );
    lod-&gt;setRange( <span class="number">0</span>, radius * <span class="number">5.0f</span>, FLT_MAX );
    lod-&gt;setRange( <span class="number">1</span>, <span class="number">0.0f</span>, radius * <span class="number">5.0f</span> );
    <span class="keyword">if</span> ( _maxLevel&lt;level ) _maxLevel = level;
    <span class="keyword">return</span> lod.release();
}</code></pre></div></li>
<li><code>createElement()</code>方法创建并返回可渲染的球体.<div class="highlight"><pre><code class="cpp">osg::Node* OctreeBuilder::createElement( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;
    id, <span class="keyword">const</span> osg::Vec3&amp; center, <span class="keyword">float</span> radius )
{
    osg::ref_ptr&lt;osg::Geode&gt; geode = <span class="keyword">new</span> osg::Geode;
    geode-&gt;addDrawable( <span class="keyword">new</span> osg::ShapeDrawable(<span class="keyword">new</span>
    osg::Sphere(center, radius)) );
    geode-&gt;setName( id );
    <span class="keyword">return</span> geode.release();
}</code></pre></div></li>
<li><code>createBoxForDebug()</code>将创建一个线状的盒子, 用于表示区域的包围盒. 它只是为了方便调试.<div class="highlight"><pre><code class="cpp">osg::Geode* OctreeBuilder::createBoxForDebug(<span class="keyword">const</span> osg::Vec3&amp; max,
    <span class="keyword">const</span> osg::Vec3&amp; min)
{
    ... <span class="comment">// Please see source code for details</span>
}</code></pre></div></li>
<li>我们还实现了一个打印访问器, 可以将场景结构, 叶子球体的名称存储到文件中. 它从<code>osgUtil::PrintVisitor</code>派生而来. 足够用了.<div class="highlight"><pre><code class="cpp"><span class="keyword">class</span> PrintNameVisitor : <span class="keyword">public</span> osgUtil::PrintVisitor
{
<span class="keyword">public</span>:
PrintNameVisitor( <span class="built_in">std</span>::ostream&amp; out ) :
    osgUtil::PrintVisitor(out) {}
    <span class="keyword">void</span> apply( osg::Node&amp; node )
    {
      <span class="keyword">if</span> ( !node.getName().empty() )
      {
        output() &lt;&lt; node.getName() &lt;&lt; <span class="built_in">std</span>::endl;
        enter();
        traverse( node );
        leave();
      }
      <span class="keyword">else</span> osgUtil::PrintVisitor::apply(node);
    }
};</code></pre></div></li>
<li>我们几乎要完成了. 现在, 在主函数里, 我们将5000个大小和位置都不同的球体, 加到<code>globalElements</code>中.
同时将计算整体的包围盒. 然后, 就可以调用<code>build()</code>方法来创建顶层的八叉树图了.<div class="highlight"><pre><code class="cpp">osg::BoundingBox globalBound;
<span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;OctreeBuilder::ElementInfo&gt;</span> globalElements;
<span class="keyword">for</span> ( <span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5000</span>; ++i )
{
    osg::Vec3 pos = osgCookBook::randomVector(-<span class="number">500.f</span>,<span class="number">500.f</span>);
    <span class="keyword">float</span> radius = osgCookBook::randomValue( <span class="number">0.5f</span>, <span class="number">2.0f</span> );
    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss; ss &lt;&lt; <span class="string">"Ball-"</span> &lt;&lt; i+<span class="number">1</span>;
    osg::Vec3 min = pos - osg::Vec3(radius, radius, radius);
    osg::Vec3 max = pos + osg::Vec3(radius, radius, radius);
    osg::BoundingBox region(min, max);
    globalBound.expandBy( region );
    globalElements.push_back(OctreeBuilder::ElementInfo(ss.str(), region));
}
OctreeBuilder octree;
osg::ref_ptr&lt;osg::Group&gt; root = octree.build(<span class="number">0</span>, globalBound, globalElements);</code></pre></div></li>
<li>将生成的场景图存储到ASCII文件中, 并开启<code>viewer</code>渲染整个巨大的场景.<div class="highlight"><pre><code class="cpp"><span class="built_in">std</span>::ofstream out(<span class="string">"octree_output.txt"</span>);
PrintNameVisitor printer( out );
root-&gt;accept( printer );
osgViewer::Viewer viewer;
viewer.setSceneData( root.get() );
viewer.addEventHandler( <span class="keyword">new</span> osgViewer::StatsHandler );
<span class="keyword">return</span> viewer.run();</code></pre></div></li>
<li>当应用启动时, 视线所及仅能看到一个盒子, 随着视角的不断推进, 你将看到盒子不断细分, 推进到最后,
足够靠近那些球体时, 你将看到叶子节点中的球体也会呈现出来. 如下图所示:</li>
</ol>
<p><img src="octree_note/result.png" alt=""></p>
<h2 id="深入分析">深入分析</h2><p>如果打开输出文件(应用每运行一次都会生成), 粘贴一部分如下:</p>
<pre>osg::LOD
    osg::Geode
    osg::Group
      osg::LOD
        osg::Geode
        osg::Group
          Ball-438
          …
      osg::LOD
        osg::Geode
        osg::Group
          Ball-729
          …
      osg::LOD
      …</pre><p>以Ball-*为名的节点是必须在场景中渲染的球体. 从之前的代码里可以得知, 球节点存储在Group节点中(八叉树的叶子节点),
Group节点是LOD更精细的一层. LOD节点有自身的位置和半径, 并会根据中心与眼睛的距离来决定子叶子是否显示出来.</p>
<p>同一层次的每八个LOD节点会组成一个Group节点, 作为上层LOD节点更精细的一层. 这就是八叉树的实际结构.
所有LOD的粗略层都会用线框盒(osg::Geode)来表现.</p>
<h2 id="更多内容">更多内容</h2><p>你会发现用四叉树, 八叉树这样的索引算法来集成场景图并不复杂. 在这一节里, 我们仅仅用<code>osg::LOD</code>节点来管理树的不同层次,
但更好的选择应该是<code>osg::PagedLOD</code>来为巨大场景的渲染提供分页功能. 就像<strong>VPB</strong>管理地形数据库那样.</p>
<p>你可能会对一些其他的空间索引算法感兴趣, 以下是他们的介绍链接:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Binary_space_partitioning">二叉空间分割(BSP)</a></li>
<li><a href="http://en.wikipedia.org/wiki/K-d_tree">K-dimensional tree(KDTree)</a></li>
<li><a href="http://en.wikipedia.org/wiki/R-tree">R-Tree</a></li>
</ul>
<p>试着用这些个方法来实现场景图结构. 你不仅可以用他们来<strong>抽稀</strong>渲染对象, 还可以更快的判断场景对象与线段(或其他操作)<strong>是否相交</strong>.</p>
<p><em>-EOF-</em></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[读《陆犯焉识》]]></title>
        <link href="essay/read-lfys"/>
        <published>2014-05-22T13:46:00.000Z</published>
        <updated>2014-05-22T13:46:00.000Z</updated>
        <id>essay/read-lfys</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>写于第1607页</p>
<p>我承认很可耻，我是看了电影才找来这本书的。恰好亚马逊上热卖减价，0.99元带回家，立刻一键下单。所以上面标识的页码，是kindle中的位置。</p>
<p>严歌苓应该是一位慈祥的女人。她的文风可以被八个字描述：不紧不慢，娓娓道来。也许是我比较浮躁，更偏爱有速度感的文字，所以初看之际，总觉不耐。以至于看到了第九章，才感悟出一点东西。</p>
<p>她的比喻很妙，也很怪。是那种需要你思考的怪，不直接，但想明白之后会觉得十分贴切，忍不住多看几眼。然后她的时间线安排堪称极致。从陆焉识在西北晕倒在冰天雪地，一下子跳到他在美国的风流事迹，你一点也不觉得突兀。就好象你是陆焉识，也一定会在那个时刻，回顾一生。最后，她是真的会写女人。说立体、跃然纸上，都不贴切，那是一枝笔能戳到骨头的厉害。如果早几年读，我恐怕体会不到这一点，然而谈过恋爱之后，才能洞悉作者的狡黠。</p>
<p>上面三点是我最佩服她的地方。然而&quot;慢&quot;才是她的最大特点。连越狱这样刺激的事情，她也只是轻描淡写，好像和平时饿顿饭、挨顿打、死个人没啥分别。有时候给我这样一个错觉：</p>
<p>陆焉识逃亡时骑的并不是好胜的青灰马，而是一头慢悠悠的小毛驴，没有什么急中生智的声东击西，倒像是随手布置的陷阱。就好象获得自由，是那么的理所当然，生怕高潮漏了出来。</p>
<p>说她到此为止，下面说一点我的思考，我的思维比较跳跃，觉得不知所云可以略过。</p>
<ul>
<li>人到底应不应该&quot;能吃苦&quot;？</li>
</ul>
<p>也是突然发现的，说一个人吃苦耐劳，原来并不是诚实的褒义，总带着点戏谑的成分。人应该能吃苦么？陆焉识在西北吃尽了苦，明明是一个翩翩美少年，竟成了人畜不分的一个物种。如原文这句话非常精妙：</p>
<blockquote>
<p>这点青稞搞乱了人和畜，生和死，摄取和排泄的关系。</p>
</blockquote>
<p>这样的一个转变，肯定是一场悲剧，是那种不敢细想，怕伤心的悲剧。原文中偏偏把这些惨不忍睹写成日常平淡的感觉，更让你感觉恐怖。这悲剧，是应该的么？</p>
<p>人，永远都拥有追求美好生活的权利。这是藏在这本书里的终极意义，藏的很深，藏的慢悠悠，却又会在你合书之际蹦到你脑海。还记得电影里，巩俐的问题始终没有得到答案：他为什么要跑？肯定是有原因的。我当时就非常好奇，到底是什么原因，电影里留了白，只能去原著找。噢，说的好明白，他必须要去见冯婉瑜一面，告诉她早年的误会，爱的误会。</p>
<p>等等，为什么他现在意识到了爱，为什么一定要在吃尽苦头之后？人永远是这样一种荒诞的动物，风流倜傥时，冯婉瑜算什么，爱只属于望达；不成人样时，冯婉瑜的一封信都如娇羞的少女，那娟秀的字迹就如少女的身姿。</p>
<p>这一面，不如不见，智商这样高的陆焉识竟不知道这样浅显的道理：冯婉瑜仰慕的，正是年少风流、俊秀潇洒的他。那么多封饱含深情的信件，都不是给这个吃尽苦头、非人非畜的陆焉识的。他看了信，就不要多想，只当无意间看了别人的信。可陆焉识老来忽然玩起了革命的浪漫，冒着挨枪子的风险也要越狱，要去见冯婉瑜。</p>
<p>这就合理了，让冯婉瑜不正常的不是什么不懂事的小女儿，而是聪明绝顶的陆焉识。</p>
<p>荒漠里泯灭人性的经历，是冯婉瑜这样的人无法理解的，浸泡在平淡美好生活中的人，很少闻到血真正的味道。所以当来自那个世界的陆焉识站在冯婉瑜面前时，只会把冯婉瑜的梦碎掉，人疯掉。</p>
<p>老生常谈，吃点苦头总是好处多。殊不知，吃惯了苦头，是有损人格的。越狱后的陆焉识永远也回不到过去了，他的人格已经永远的失去了。</p>
<p>或许，去见冯婉瑜只是他的一个幌子。他没有说出心里的呼声：人，永远都拥有追求美好生活的权利。他一定要去试试。见原文：</p>
<blockquote>
<p>上千个管教干部击毙了不屈的牲畜，但总有一小部分撕开缜密的猎网逃出去。那都是牲畜里的最优秀分子，勇敢强悍矫健，它们可以跳得比人头还高，跑得比子弹还快，总是在踏伤或踏死一两个人类成员之后自由地远去。</p>
</blockquote>
<p>这或许是陆焉识越狱的一个注脚。</p>
<ul>
<li>可怜，还是爱？</li>
</ul>
<p>人在得不到爱的时候，会退而求其次的追求被可怜。传统的女性正是深谙此道，严歌苓看透了这一切，躲在文字后面轻笑。陆焉识早年对冯婉瑜，恰恰就是觉得可怜。再早些，是觉得恩娘可怜。他对她们做的一切，都是基于这一个出发点。爱呢？他给了望达，那个因为不可告人的原因而羞于在大街上和他走在一起的外国女人。</p>
<p>爱，总是往上看的；可怜，才是俯视的姿态。可怜，是给予弱者的“爱”。</p>
<p>还记得高中最后一堂语文课，老师给我们留下的一句话：“男人，应该去找一个你尊敬的女人；女人，应该去找一个你仰望的男人。”看看，尊敬、仰望，合起来不就是敬仰么。你爱的人，一定是至少有一个方面让你敬仰的，无论是美貌还是才气。</p>
<p>对于沦落到一无是处的陆焉识来说，冯婉瑜那娇羞的字，已然成了他生活中最高贵的东西。</p>
<p>于是他走的义无反顾。</p>
<p>荒诞的是，对于冯婉瑜来说，这样的他，又焉识乎？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[工作变动]]></title>
        <link href="work/needdepth"/>
        <published>2014-05-09T00:00:00.000Z</published>
        <updated>2014-05-09T00:00:00.000Z</updated>
        <id>work/needdepth</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>记得学生时代的我，为了展示自己博览全书，在一次随笔作文里，从经史子集到西方名著，随意点评，臧否人物，不亦乐乎。老师在评语里赞扬了我一番后，留下这么一句：“你的广度有了，能否再在深度上下点功夫呢？”</p>
<p>或许是对那篇文章十分得意，以至于我对于这么一句听起来不怎么舒服的评语印象颇深。不过我不得不承认这句话戳到了我的痛处。当时，四书五经，不过是浮光掠影；莎士比亚，仅限于知道书名。看了几篇评论和介绍，就敢妄加评断，现在想想真是羞愧不已。这浮夸的种子，从那时便已经开始慢慢发芽了。</p>
<p>什么都了解，却什么都不深入。这个毛病是非常要命的，它不仅会让你花费大量时间在各个领域浅尝则止，还会让你时刻有一种自满的心态。明明是不到半瓶子的水，似乎掺点其他瓶子的盐，就会满似的。</p>
<p>发现自己已经病入膏肓，还得从近期的工作说起。</p>
<p>才工作不到三年的我，在采集团队，已经开始接触面试新员工、培训新成员的任务了。而本职工作上，无论从业务的角度、还是编程的角度上看，上升的空间也十分的狭小了(时常有种没有人比我更懂得采集的感觉)。刚开始，这种感觉会让我膨胀一会，逐渐也把自己当成专家看待了。但气球上了天，终究会爆掉。在采集模块逐渐成熟的情况下，我被分配去做一个实时数据展示的模块，它要求随着实时数据的产生，在甬道中同时绘制出曲线。开始我没觉得有多困难，毕竟有诺大的互联网不是。于是我开始调研各种技术，从微软的GDI\GDI+，DirectX，到工业标准OpenGL，再到Qt中比较有名的控件QWT。GDI\GDI+和QPaint类似，都是从点、线、面等基本元素开始组建的，而再尝试入门OpenGL的时候，我真是尝到了苦头。开始感觉有点不知所云，连环境都配置的一塌糊涂，各种警告不说，连显卡驱动我都更新了好几回。更别提有关数学的内容，时刻提醒着我考研考的一塌糊涂的数学。热心的领导给我介绍了这方面的牛人，而这位现在成为我领导的大牛给我讲解了他们在业余时间开发的一套程序。里面精妙之处不胜枚举，代码干净简洁，十分符合我的美学要求。而在2D方面，他们也仅仅用到了Qt最基本的Graphics View Framework。没有用控件，没有用其他的图形库。这的确让我开了眼界，大牛耐心的讲解也让我尝到了Qt精妙的甜头。</p>
<p>可能是井场上的程序写多了，我十分在意程序所依赖的环境，Qt和.net一样，在这上面让我天然的厌恶。.net不提，必须安装.net Framework环境。而Qt那不胜枚举的dll的也好不到哪去。另外，由于井场多以xp为主，甚至还会有2000，Qt的跨平台特性没有体现，而且还会在效率上吃亏。比起Windows API，真是不知道差了多远。</p>
<p>但那是多么狭窄的一个业务场景呢？复杂的机型，老旧的系统。除非你希望开发维护一辈子MFC，或是各种深入研究无聊透顶、名字冗长的Windows API，否则真的找不到理由将宝贵的时间浪费在这样的地方。</p>
<p>还好我在一年前就察觉了MFC的弊端，逐渐将精力放到了STL以及标准C++上去了。否则现在的处境只能更惨。Qt出现在我的视野内，也是在去年，坐在我后面的同事由于没什么活可做，百无聊赖的学起了Qt。我这才开始明白原来不用Windows这一套东西，也可以作出漂亮的界面。当时起了性子，疯狂的学了一阵子，也是浅尝辄止，毕竟想学的东西太多了。到了去年年底，领导决定<strong>再一次</strong>的重构采集系统，说到用什么来开发界面合适，我信口就推荐了Qt。而领导恰好也在别的项目上看到了Qt的成功运用。这才正式将Qt引入实际的项目开发。前期我也是兴趣盎然，又是抱着书看，又是各种分析文档。在网上看到有人模仿<a href="http://blog.sina.com.cn/s/blog_a6fb6cc90101e8lf.html">360界面</a>，简直惟妙惟肖，更是激起了我的无限乐趣。于是自作主张将这种类360风格的界面引入了最新的采集系统。我再次发挥了<strong>什么都会一点</strong>的&quot;超能力&quot;，从图标到美工，再到细腻的界面跳转事件，以及表皮架构的设计。奠定了总体风格(貌似到现在还没有大的改变)。可惜刚刚竣工，领导就将&quot;更重要的&quot;后台采集框架交给了我负责。撇开&quot;什么都会一点&quot;的超能力，我最擅长的还真就只剩底层后台框架的设计了。于是，后续的经历再次与Qt失之交臂了。</p>
<p>缘分总是这么神奇。回到之前提到的大牛，我看了他的代码后，夜不能寐，寝食难安，原来在这样一个公司也会有这样好的代码存在！又是热心的领导遂了我的愿。在这周，我正式拜了图灵，入伙该大牛的团队里。但直到这时，Qt对于我来说，还属于&quot;什么都会一点&quot;中的技能点而已。</p>
<p>正经的来说，Qt对于一个人理解C++的本质，是大有裨益的。譬如我刚开始写C++程序时，连如何写一个完整的类，都是很犯愁的。而且由于中国特色，本土C++工程师往往都是披着C++外皮的C程序员。将面向对象思想贯彻的最好的，也还是Qt。所以如果你写惯了Java或是C#，再来写Qt，会很舒服。而Java Swing和Qt在界面设计方面，几乎也分不清是谁抄的谁了。也许是入门太容易，我对待Qt，至始至终都没有抱着深入学习的态度。毕竟在我心里，纯粹的C++或是纯粹的C程序才是王道。</p>
<p>于是在面对入伙后第一个&quot;投名状&quot;任务时，&quot;什么都会一点&quot;的弊端展现无疑了。能想象出来么，连在Qt Creator里对一个界面布局我都折腾了一上午。我这才发现，我对于Qt里的布局管理器竟然是一无所知的。控件的摆放，我还停留在MFC时代(也就是手动对齐)。而我看到同事绘制的界面各种拖拽、缩放自如的时候，我才意识到布局管理器的重要性。是的，从这时起，我已经开始怀疑自己无往不利的&quot;什么都会一点&quot;之超能力了。</p>
<p>后续需要用到的Graphics View Framework，更是让我头疼，旋转缩放函数到底是怎么使用的，为什么用起来不是我想象的那样。对着API文档看来看去，看不出所以然。看例子程序吧，额，难道没有简单点的么。算了，还是直接参考同事的代码好了，咦，他这样写的用意是什么呢。总不好意思事无巨细的去问别人吧。</p>
<p>这时候，我基本已经浮躁的无以复加了。</p>
<p>语文老师的评语，应该是从天上飘来的。“广度有了，是否在深度上下点功夫呢？”</p>
<p>我突然神经一紧，明白了老师的良苦用心。老师过于委婉的说出了对我的希望，孩子，虚心点，海里的水很深，别沉溺在小池塘里坐井观天了。</p>
<p>我删掉了那些东拼西凑准备交差的代码。重新捡起了《C++ GUI Qt4编程》，准备真正下点功夫，每一行代码的敲起。有些事，真的没有捷径。</p>
<p><em>-EOF-</em></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[生活的意义]]></title>
        <link href="life/thinking-in-life"/>
        <published>2014-03-27T03:23:00.000Z</published>
        <updated>2014-03-27T03:23:00.000Z</updated>
        <id>life/thinking-in-life</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>大概是几天前，Jian对我说，不知道生活到底有什么意义。那时的我们走在空旷的大街上，正准备去电影院去看刚上映的《白日焰火》。</p>
<p>我当时心里却充满着意义。天天加班的乏味生活，能够抽出空来看场电影，多么有意义！如果恰碰上一场好电影，那真是生活的恩赐了。当然，我只是心里想想，如果说出来，又要遭到Jian的鄙视了。</p>
<p>今天回家，跟爸妈汇报完最近的工作窘境，反而有点失落落的。这样的工作，这样的环境，与我刚毕业时的理想相差万里，但在这不长不短的三年间，我也渐渐明白了自己所处的位置。这个世界太大，不能想当然，有太多我没见过的山，有太多我没见过的海。渺天地之一粟，毫不夸张。</p>
<p>生活的意义在我这里最终是归于荒诞的。一切都是那么合情合理，那么无懈可击。你想随口抱怨，却会在随后的深思中发现完全不应该。怨不了天，由不得人。世间万物自然生长，而偶尔交错的枝桠，却是那么的荒诞。</p>
<p>也许只是求而不得的骚动呢？人们往往是求A的时候得到了B，一拨人暗骂了一句，扔了B，继续寻求A；另一拨人觉得B也不赖，便如世事洞明般的说一句：得不到的不强求。而最幸运的那一拨，终于得到了A，若干年之后，发现A也不是自己想要的，于是蹉跎一世，悔不当初。</p>
<p>到头来，所有人都是悲剧，整个人类史就是一场悲剧的迁徙。人往往会花上一辈子去想明白自己要的到底是什么，可是时间往往饱含最大的恶意，用匆匆几年春秋，嗤笑着人类的可笑。想想就觉得荒诞。</p>
<p>我觉得生活真正的意义，都曾在我们每一个人心里暂留。只是它太过匆匆，给我们留下了完全不同的印象。我们都以为那才是真的，其实呢。</p>
<p>没有意义，也许才是最大的意义。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[采集器设计思考]]></title>
        <link href="work/thinking-of-das"/>
        <published>2013-11-10T00:00:00.000Z</published>
        <updated>2013-11-10T00:00:00.000Z</updated>
        <id>work/thinking-of-das</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>领导总是想一出是一出，C#的移植工作才刚刚走上正轨，便把我们叫停，还是让我们把精力放到采集模块的设计上去。</p>
<p>自我入职以来，我便一直从事着与采集相关的工作。开始我觉得这东西很神秘，很底层，可以有机会破解各类数据文件。后来渐渐觉得这是个无比简单的活计，也不会被领导重视。再后来多次重构采集框架，让我意识到，挑战无处不在。</p>
<p>采集是个什么样的概念呢？就我的工作而言，其业务场景一直局限于井场仪器实时数据的截取。钻井过程中，综合录井仪的传感器，会将各种特征参数的值测量出来，在经过一些简单的计算，形成一套实时变化的数据，因仪器类型的不同，可能会存储于本地数据库中，可能只是暂存于临时文件，更先进些的会组织成<a href="http://home.sprynet.com/~carob/index.htm">WITS</a>标准的格式，发送到总部服务器进行存储。这些实时数据，被研究的价值并不大，传回总部服务器后，也多数被绘制成实时曲线进行展示。仅此而已，也许出现井喷等事故时，可以将曲线回放，分析事故原因。</p>
<p>那么由此可见，采集的重点，其一在于真实性，其二在于时效性。这有点像是新闻了。保障真实性，就是数据不能被人为修正，传感器测量或计算的值应该原封不动地被传回；保障时效性，就是传感器刚一产生数据，就要被马上截取，并传回总部，期间时差不能超过5秒。所以，在设计采集程序的时候，第一要务是找到哪一个数据表、数据文件、数据包是&quot;原生态&quot;的，第二就是如何最小的减小开销，极大程度的减少时间消耗。功力就在两个词：观察、高效。</p>
<p>遇到没有见过的仪器，首先就是要分析该仪器是如何处理数据的，最好能拿到它配套的计算软件，检查每一个有可能&quot;藏污纳垢&quot;的位置，快速定位应该取哪里的数据。然后就是考虑算法，如果是文件，如何能最快定位到新数据产生的位置，截取需要的值；如果是数据表，如何能优化SQL查询语句，如避免使用order by等费时的命令。</p>
<p>以上基本是我第一年努力的目标。毕竟现场条件艰苦，不宜久留，快速找到自己需要的东西是最基本的能力。</p>
<p>这个层面仍然属于业务范畴，真正落实到Code，就不得不未雨绸缪了。你想，如果遇到一个你完全不知道结构的二进制文件，让你快速解析出所需的数据，需要多长时间？如果遇到你不熟悉的数据库，让你从中获取数据，你又需要多长时间？</p>
<p>这就需要提前积累，如必须设计一个公共的类，所有对于数据库的增删改查都应该封装成一个统一的接口，无论你面对的是SQL Server、Access、Foxpro、MySQL、Firebird还是SQLite，都执行相同的方法，那么取数据库特定表的数据，不就变得易如反掌。文件也是一样，文件的组织结构无非以下两类：</p>
<ol>
<li>一个文件一条数据<ul>
<li>Key/Value形式</li>
<li>结构体组织</li>
</ul>
</li>
<li>一个文件全部数据<ul>
<li>Table形式，有表头，然后一行一行数据</li>
<li>结构体组织</li>
</ul>
</li>
</ol>
<p>结构体组织多为二进制，Key/Value和Table形式多为明文文本。前者解析的重点是结构体，后者解析的重点是表头。其余的操作是否也可以封装为公共类？这样我拿到结构体或表头，便能够立刻解析出最新数据。</p>
<p>如果是较先进的仪器，符合WITS标准，并具备WITS发送能力，那么是否也应该准备好网络接收的类，无论是TCP Server还是Client，UDP，串口还是工业级别的OPC、DataSocket，我仍旧可以调用同样的方法。这样封装之后，我随时可以配置自己的接收端，接收到需要的数据。接收到了数据，是WITS格式的，还需要解析，这个操作也是需要封装的。</p>
<p>好了，需要储备的技术还真不少，数据库、文件、网络、串口、各种协议。这些都是公共基础子模块，是必须不断优化的。这些代码的优劣是采集程序质量的决定因素。</p>
<p>这就是我第二年的目标，准确的说，其实没有做的很好，期间也后悔过多次在大学没有夯实基础。没有几手硬功夫。</p>
<p>其实到此为止，核心的东西我们都设计地差不多了，最后也是最难设计的，便是交互界面。还好在能源行业，对于用户体验并不是互联网那套思路，井场的工人们，也没有时间无聊到观察界面是否优雅。界面的目的就是最快最直接的呈现软件具备的功能。让现场人员，可以按最少的按钮，输入最少的信息，以最快的速度完成一次操作。(互联网正好相反，设计人员更希望用户多花点时间在使用软件上，最好流连忘返，忘了吃饭)</p>
<p>第三年我基本在参考国外程序的类似程序，我发现国外的软件最为突出的特点就是灵活。他们的代码里一定没有任何写死的硬编码，每一个可能改变的地方，都会留出配置接口。但这样的缺陷也是明显的，配置界面会非常的复杂，然后后台数据库设计的非常的复杂，所有表、字段都是灵活的，都有元数据字典来管理。这就是老外的舍取:</p>
<p>他们选择了<strong>七十二变</strong>，放弃了<strong>傻瓜易用</strong>。他们的软件定位在给专业的人用，无形中也提高了他们软件的品味。</p>
<p>品味，是一个很玄妙的词，乔布斯有他的品味，苹果才如此优雅，你根本不需要学。但盖茨难道没有他的品味么？Windows难用的恰好合适，刚好让你能学会，还颇有成就感。再看看Linus呢？他的品味独具特色，Linux超级难学，人家压根就没准备给小白用，那是黑客与天才的系统，他们需要工具，而非玩具。</p>
<p>回到采集，我需要做的事情，也就是找准软件的定位，然后恰如其分的给出软件应有的长相。这里面的主角依旧是配置，是不是也做到了每一个细节都能被配置？要知道井场除了综合录井仪，还有LWD/MWD，钻参仪等等，难道每一类仪器都需要重写一套采集程序么？如何拯救他们？是不是该考虑一下WITS统一的标准带来的好处呢？</p>
<p>好的软件，是一个顺畅的数据流，采集软件，更像是诗经的开篇:</p>
<blockquote>
<p>参差荇菜，左右采之。</p>
</blockquote>
<p>WITS标准就像我们的箩筐，荇菜便是数据，软件就是这条美丽的河。</p>
<p>&lt;- 全文完 -&gt;</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[苦闷时光]]></title>
        <link href="life/distressed"/>
        <published>2013-10-13T00:00:00.000Z</published>
        <updated>2013-10-13T00:00:00.000Z</updated>
        <id>life/distressed</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>本来想写一篇牢骚文，抱怨爱情的伤痛，处境的尴尬，工作的不力。</p>
<p>但最终还是删掉了那些废话，我想写一篇总结。</p>
<blockquote>
<p>每个人的命运都是悲剧的。</p>
</blockquote>
<p>我想，这就是我一直以来思考的生命的意义。</p>
<h2 id="说不出的话">说不出的话</h2><p>很难想象，我居然也会落得如此田地：有话说不出口。</p>
<p>难言之隐，竟然生生的发生在了自己的身上，我仍有点不敢相信。曾经的直抒胸臆、酣畅淋漓，现在的无话可说、无人可诉。我似乎触碰到了自己的局限性。好似长久以来都在潜水，没有一个机会，浮上来喘口气。</p>
<p>这么描述，好像我有什么隐疾一样。虽然明天就要体检，但至少目前还没有身体上的伤痛，上述都只是在说精神。那算是一种压力？一种迷茫？一种无所适从？</p>
<p>说不出的话，写都不会写，憋着，用内功消化。</p>
<h2 id="迷路的尴尬">迷路的尴尬</h2><p>曾经一切都很明确，我至少能看到命运的手。可，现在我瞎了。</p>
<p>上周一个人的深夜，忽然觉得自己在这个世界上本来也是有什么使命的，要不为什么不关心生活，不关心美食，不关心华服，甚至不关心朋友和亲人。我保留着人性温存的最小集合，仅此而已，人际让我觉得疲惫，我是社交冷淡者。</p>
<p>但那夜细细想了想，忽然自嘲，我有个屁的使命。小时候以为自己是上帝，并深信不疑，现在甚至不敢自诩程序员。只能说，我略懂计算机。</p>
<p>莞尔一笑，我还有那么自负的曾经。</p>
<p>一辈子，如果仅仅用来&quot;生活&quot;，或是&quot;享受&quot;，对于我来说，是无法忍受的。可是我说不清自己到底要干什么事。冥冥之中，总觉得有些事舍我其谁，也许人类历史某个犄角旮旯里，躺着我这样一个救世主。</p>
<p>救世主应该具备先知的功能吧？可我迷路了，是否反证我并非救世主？</p>
<p>我有什么特质是别的没有的？找不到？甘于如此平庸？</p>
<h2 id="工作的失意">工作的失意</h2><p>有个同事，是和我一起进公司的，打我认识他起，他就在捣鼓一个功能：实时曲线与仪表盘的绘制。而他也只研究一种技术:Flex。说实话，那个功能市面上有无数实现，而Flex随着HTML5的诞生也逐渐走向没落。所以我向来是很瞧不起他的。</p>
<p>两年多过去了，他的领导换了三四波，他干的事却一直没有变。仍然是曲线、仪表盘。期间上面的领导曾经做出了很多决策，如购买国外成熟的绘图插件等。他都没吭声过。决策们躺在无人赏光的文档库里，他的曲线和仪表盘却越来越象样。那东西本来就是展示出来给人看的，容易出彩。今天突然被领导发现了，叹为观止。用当时在场另一位同事的话说，和国外Landmark的Insite做的毫无二致。</p>
<p>再说一个同事，在本行业里摸爬滚打也有几年了，比我晚一年进的公司，当时作为行业专家引进的。他来了之后并未给我们项目带来多少新鲜的血液，以前做的东西也保留的小心翼翼。我怀疑他是否是名副其实，属于养老派。</p>
<p>可是这周项目组引入了一套成熟的WCF+WPF的.Net项目，让大家熟悉熟悉，为之后的对接做好准备。我们组以C++与Java见长，都不太会C#，所以大家也都是云里雾里看热闹，偷摸猛补C#。他突然说：我模仿这个架构，搭了一个Demo，大家来看看。边说着还嘿嘿笑着，回头对我说：这还挺好玩的。</p>
<p>这两位同事的事情，其实不值一提，互联网公司估计有太多这样事在发生。而对于我却是有十足的触动，因为都是我能做到的，但我没有去做的。我既耐不住性子，专心致志；也爱挑Easy模式，自我陶醉。而他俩，只不过靠了坚持与挑战。</p>
<p>Hard模式不是人人都能通关的，但通关的皆不俗，得到的快乐也不同。
一本书能够读完，而且反复读好多遍的，也很少，能做到也不简单了。</p>
<p>PS: 第一位同事在捣鼓曲线和仪表盘的时候，我把《C++ Primer》的前三章看了三遍。</p>
<p>第二位同事在钻研代码，理出头绪的时候，我不耐烦的看着《C#图解教程》，顺带做点核对数据库表字段的工作。至今，这本书也没看完。</p>
<h2 id="说点正事">说点正事</h2><p>无论如何，屋子要打扫，过期的食物要清理，衣服要洗，床单要在规定日期换掉。否则，只会更加苦闷。我不是做保姆的材料，但，不得不硬着头皮。</p>
<p>我还是相信自己有某种特质是与生俱来天赋异禀的。只不过我还没有发现，我这样等到70岁，也许也只是发现身边有一个69岁的老头样样比我强。我一天到晚读各种资讯，关注程序员的方方面面，也仅仅发现自己比较会挖坑而已。乱花渐欲迷人眼，不予置评。</p>
<p>我想，我应该不是没有发现，而是贪心更好的，明明使命是做一个举世无双的马桶，非要想着可能是做大陆首富。减法，会不会更有效果？</p>
<p>工作上还是不要那么短视吧，努力干实事，不用担心没人在意。只用担心，别人在意时，能否拿出值得别人在意的东西。</p>
<p><em>That&#39;s all, thank you.</em></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[噩梦]]></title>
        <link href="life/nightmare"/>
        <published>2013-07-17T00:00:00.000Z</published>
        <updated>2013-07-17T00:00:00.000Z</updated>
        <id>life/nightmare</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>今天中午睡的很沉，做了一个很长的噩梦。起来之后，浑浑噩噩，不知所以，思绪繁杂，喜忧参半。</p>
<!-- more -->

<p>从上周六到昨天，一直奔波在大西北广袤的土地上。看了许多美景，也发生了许多事情。其实我是带着很多不情愿出发的，我就想回北京，不想在这里多呆了。可是师傅强烈的意志把我说服，带着些无奈，毫无准备的上路。</p>
<p>其实这半年来的工作让我很失落，重构过多次的采集器，也陷入鸡肋的境地，那些代码曾经是那么的有活力，但我深知，这个软件彻底死了，我的努力还是多余的。我反反复复大规模重构了有两遍多，第三遍还在继续，可是我真的不想再这样认真的继续了，想过很多次，要不草草收尾吧，再去做新项目，再去慢慢吸取教训。但我心里又有点不舍，没有人看到这里面的心血，正如没有人觉得这东西有什么价值一样。</p>
<p>这次出差快一个月了，钱花的差不多，人也快得罪的差不多，我一直想卖力的干点实事，实在不行，我每天都去上井？可是我真的不愿意浪费那时间，这算不算眼高手低呢？实际上，时间还是被浪费了，那些浅尝辄止的尝试完全没有一点意义。跟着IceSoul学了挺多皮毛，有过很多次兴奋，了解了很多不曾接触的领域。明白了自己的浅薄和渺小。无论是做人做事，还是专业与性格，都与别人有太多的差距。还记得去年写的<a href="./end-of-2012">年终总结</a>么。也许那就是我的硬伤吧，想做的完美，却又缺乏见识与阅历。最终就是做了许多无用功。</p>
<p>IceSoul说的很对，我心太浮躁了。每个问题都很难深究而后形成自己的看法，往往都是人云亦云，或是故弄玄虚。枉我还是正经的计算机专业出身，很多时候都表现得太不专业。技术上又容易固步自封，缺乏深入的思考。再就是喜新厌旧，容易三天打鱼两天晒网，各种秒射。要不是工作的原因，我想我很难能在C++上有什么发展，一定也是玩玩就扔掉了。他说我像个小孩子一样，是一种幼稚，这也许不无道理。</p>
<p>可能是漏了底，其实我来这边，是很想要出点力帮点忙的，可是渐渐发现IceSoul基本上都自己搞定了，反倒是我从他那里学到了挺多，他估计对我也不太信任了，知道我能干什么不能干什么。走的太近就会有这样的危机，这就算是代价了。我忙乎来忙乎去，还不如把自己的事情干好，回北京老老实实的生活。</p>
<p>可是回去就能老实生活么，公司就要搬到昌平，难道让我去租房？我真的要想办法调换部门了么？还是直接投投简历，换份工作？更头疼的是要怎么准备结婚事宜呢？我现在有什么基础，又有什么资本呢。想到这些，就很难无忧无虑。加上父母一直催促出国或是考研，更是火上浇油，压力山大。</p>
<p>小王说得对，有能力的人早就离开了。师傅说得对，在这里基本学不到什么东西，不如小公司，不如油田应用技术部。IceSoul最早也说得对，现场的工作不难做，要看谁做。</p>
<p>以上三位都是我的师父，从小王那里学习与人打交道的能力，处世避免显得过于生硬。从师傅那里学着如何做专业软件，避免走太多弯路。从IceSoul那里学如何处理工作，如何具备清晰的思路，敏锐的了解每一个人，做到知人善任。</p>
<p>这三位师父在软件开发里，对应的就是如何做需求、如何做开发和如何做管理。每一个步骤都需要具备他们身上的特质，才可以做的完满。可这三样，一样也不适合我。</p>
<p>当我不知道如何与人打交道，如何游刃有余的混迹社会的时候，我就安慰自己，做好开发就好了。当我走过一个又一个弯路，做得东西得不到别人认可的时候，我就安慰自己，可能我具备的是综合素质，对整体项目能够进行把控。当我看到IceSoul是怎么处理现场的各种情况，各种人的时候，我只好安慰自己，年纪还小，唯有多努力。</p>
<p>这一个月虽然在工作上做得并不多，但更加看清了自己，无论是感情、还是事业上，都算一个警醒，或许以后，知道该如何为人处世，如何形成自己的风格了。</p>
<p>我想，总会有自己适合的不是？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[终是分离]]></title>
        <link href="life/last-sentence"/>
        <published>2013-07-09T00:00:00.000Z</published>
        <updated>2013-07-09T00:00:00.000Z</updated>
        <id>life/last-sentence</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>她反复说我要挂了的时候，我的脑海里是一幅幅画面。夜里走在广平大街上的、满头冒汗去机场的、心有忐忐地前往宝鸡的、一起骑车在杭州街头的。那些画面感觉黏在心头、混在血液里，生拉硬拽了一番。很难扯动。</p>
<p>好不容易扯开了一层皮，就有点像冷水过了一遍久未冲洗的褶皱一样，空空如也的缝隙里冷空气肆意流窜着。空着冷，也是抽着疼。就像通常脱了皮，起开一个口子，就想忍痛整个扯掉。让新生的皮慢慢与空气交融，慢慢生长。</p>
<p>来了三封短信。语气开始变得客气，里面似乎又带着些嘲讽，又有着点委屈和无奈。很夜了，最近都不知道什么是夜。是的，没有她我也会熬夜，我也会照样浪费时间，我也会一次一次的去西北。好像没一点区别。</p>
<p>说无悔，但其实总是带着些将就的。有些事情发生，我是很敏锐的，但我始终让自己保持迟钝，我记得&lt;离婚进行时&gt;里讲的那句，感情是讲不了道理的。于是我就退，能退就退，放弃自己的立场、习惯、甚至是尊严。做了很多我以前根本做不到的事情。我觉得时间是最强的武器，只要挨上个两三年，互相熟络了，离不开了，就磨平了互相的棱角，抱在一起不会痛了。可是，终究敌不过无缘。</p>
<p>这次栽的不轻，吃了很多亏，也真的明白了很多。债永远还不轻，太沉重了，这个尴尬的年纪，又是这样的事情。真的不想再爬起来了。小心使得万年船，人的事情，来不得一刻的放松。可是，我们的初衷是什么？不就是放松和快乐么。随心所欲不逾矩，孔子都需古稀才能做到，二十出头的年纪，又如何能驾驭得了。</p>
<p>感觉突然回到了几年前大学的日子，那种怎么努力也得不到自己想要的窘境。最后总会感慨，还是不够努力，总有那么些情况，让你的努力还不够。这是人性的束缚，也是年轻的代价。终是命运的折磨。</p>
<p>还是孤独点好，再多痛苦折磨只是自己承受，不干别人的事情。可感情处理的不好，也许是两个人终身的代价。再次说明了不能没有底线，任何情况都是这样，触碰了底线不能手软，否则付出的将是几倍于此的代价。</p>
<p>我已经在这个世界上存在了8535天，至此，没有一件真正值得骄傲的事情值得说道。太多的遗憾已经淹没了我的神经。如果再来一个8535天，会不会有不同？不知道，但能确定的是，那时已经无法回头。</p>
<p>只差40天而已。数字让人心痛。但无法回头了，彼此都无法接受了。</p>
<p>18岁之后，以为想怎么样就怎么样，不假思索，随性挥斥着时间与决定。连续碰壁，头破血流，收获的，竟然只是16、7岁年华在某本书上看到的一句话而已。这些话还会穿插在生命中出现，以前把它们当故事听了，现在才知道，原来自己也会有故事，终有一天，也会成为故事的主人公。他们承受的痛苦与折磨，自己只会感受的更真切。</p>
<p>此刻的靖边小县，窗外雨水滴答滴答的下，深夜里听得格外不是滋味。</p>
<p>17岁我听过这样的雨、20岁也听过，今年23岁，又在听这样的雨。</p>
<p>写到这里，她来了一个电话，口气缓和了许多。我竟又有些心软了，能不能就这样算了，过去吧。这让我想起，中午师傅说，在这公司把人待废了，如果我在小公司，水平肯定不会是现在这样子。我何尝不想跳巢，可是我想着，要不再待待看吧。又让我想起，老爸晚上给我电话，问对未来有没有什么考虑，研究生还有没有想法。我不是没想法，可是得过且过吧。毕竟我又不是活不下去了。</p>
<p>就像沸水青蛙，如果不是突然把它烫着，它完全不知道会如何死去。</p>
<p>感情、工作、和生活，都是需要决定的。否则，就只好等死吧。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[花一些时间思考]]></title>
        <link href="life/take-a-moment"/>
        <published>2013-07-05T00:00:00.000Z</published>
        <updated>2013-07-05T00:00:00.000Z</updated>
        <id>life/take-a-moment</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>今天小王赶到靖边，他是个好事之人，便邀这边的同事一起去搓一顿。我恰好也在，便一起同往。</p>
<p>酒桌，向来是我最厌恶的地方之一。烟雾缭绕，红着脸吹牛，顿感生命的无聊。我是个怪性子，到了这种气氛下，便警觉的很，不容丝毫轻松，拘束地不愿说一句话。我坚持滴酒不沾，所以容易冷场，明知道不太好，但也奈何不了自己。解决方法就是不去这样的场合，既然去了，就得承受尴尬。</p>
<p>酒足饭饱之后，重新坐在电脑前。突然思考了很多。也许是回忆了一天内和女友的对话，也许是瞥见了本科同学的硕士生证书，也许是看到了小王，想起了去年的自己。反正，褪去了轻浮的兴奋，放松的傻笑。一个人呆坐着，想花一些时间思考。</p>
<p>好久都没有更新这个博客了。这个既最下功夫，又花钱买了域名的博客，反而没有新浪博客更新的勤快。很忙吗？这是她经常问的一句话。这倒是一个最自慰的借口。</p>
<p>看过我以前博客的人，都能感觉到那种硬撑着的正能量，或是自我哀怨的小调子。我还经常自诩文人，其实是给自己贴金，给文人丢人。唉，越来越没自信了。</p>
<p>我想到了过去，想到了未来，昨天中午迷迷糊糊做的那个难受的梦，还横桓在我心坎里。这也许都是酒桌这样一盆冷水把我激醒的。戳中了软肋，才会另寻生路；言中了痛处，才会奋起直追。我不爱去同学聚会，不爱参加各类活动，就是怕自己的弱点暴漏在众人下，被无形的气氛逼得抱头鼠窜。</p>
<p>所以我容易沉迷在自己的世界里，玩一些小技术，学一些小知识。对那些未知领域尤其着迷，因为这里我即使受挫，只需要一点耐心，花些时间，就能获得莫大的成就感。这种感觉是容易上瘾的，有时以为找回了自我，其实是迷失而已。</p>
<p>我相信，人与人的差距并不是因为社会地位、家庭背景、成长历程等等我们习以为常的原因，而是思维观念。也许另一个世界里的我，就不会有这许多思考，依旧安于做一个小屌丝，依赖着可怜的成就感为生。也许又一个世界里的我，会彻底转变观念，直面自己的弱点，在各类场合表现出成熟的风范，能够不那么自私，能够让身边的人舒服。</p>
<p>可是这个世界的我，依旧难以摆脱根深蒂固的观念。这便是一种科学的宿命。少有人可以躲得开。</p>
<p>很多人说，你为什么就不表现出“好”的那些行为？</p>
<p>因为你懒，因为你自私，因为你娇生惯养，因为你意志薄弱。</p>
<p>我听着这许多话，继续自怨自艾着，想做点什么摆脱这样声音的围剿，想成为那个“好”的我。我对不起身边的人，我活着的方式，以为会给你们带来快乐，实际却是让你们莫名的痛苦。我不断的给这些人道歉，到最后也不好意思道歉了。也许我应该做的，只是躲入自己的森林，老死不相往来。</p>
<p>我经常那么想，这样想下去，不知道还会有怎样的心态。</p>
<p>而，正是这些脑子里装的，最底层的东西，观念和心态，决定了你是怎样的人。</p>
<p>如，我这样的，永远只能写出自怨自艾的文字，恬不知耻的拌着可怜。</p>
<p>这是精神上的乞丐，没有自己的东西，还会被人认为是自私的家伙。</p>
<p>哎，自己的事情，写在自己的博客里，谁也别看。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[有多少虚伪的了解]]></title>
        <link href="essay/shesaid"/>
        <published>2013-06-30T00:00:00.000Z</published>
        <updated>2013-06-30T00:00:00.000Z</updated>
        <id>essay/shesaid</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>有多少虚伪的了解，能让你牵肠挂肚。</p>
<p>有多少虚伪的了解，能让你无法释怀。</p>
<p>他虚伪地认同了他的虚伪，你失落地消化着你的失落。</p>
<p>有多少虚伪的了解，能让你光阴虚度。</p>
<p>有多少虚伪的了解，能让你自我满足。</p>
<p>他诚恳的保持了沉默，你独在深夜局促。</p>
<p>有多少虚伪的了解，能让你脱口而出。</p>
<p>有多少虚伪的了解，能让你不去琢磨。</p>
<p>他说那都是兴之所至，你说那不过是形式。</p>
<p>有多少虚伪的了解，能让你形同陌路。</p>
<p>有多少虚伪的了解，能让你抱头痛哭。</p>
<p>他不解为何统统都有恶意的标签，你说无知本身便是最大的恶念。</p>
<p>有多少虚伪的了解，现实在这边，爱在那边。</p>
<p>心意是否离别？爱是否无解？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[也说青瓦阁楼]]></title>
        <link href="essay/qwgl"/>
        <published>2013-05-10T00:00:00.000Z</published>
        <updated>2013-05-10T00:00:00.000Z</updated>
        <id>essay/qwgl</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>请先看看<a href="http://xn--xwq36n0ppci8b.cn/content/loft">这里</a>。</p>
<p>青瓦阁楼是一个意象，那里的瓦不是青的，说阁楼也有些小气，那是完整的一层楼。我最迷恋的顶楼。</p>
<p>但青瓦阁楼也是一间房，是主人起的名字，飘逸秀气，Jian很喜欢，那真是一间阁楼，很小，但却有一张床，一个浴缸，一个天窗。都是极尽惬意的事物，稍稍想象下，心里都会痒。可惜，我们虽然订了青瓦阁楼，但却以免费升级的名义被请往一层的主人房。未免遗憾。</p>
<p>住的房里，有天来了只老鼠，趁着人们酣睡的深夜，偷吃了一个大苹果。它仅咬下了一小块，但肉啃的很干净，留下些细碎的皮屑。以留作清早与我们分享。“这么一说，其实真是件恶心的事情。”(大笑)</p>
<p>不知道那只小老鼠，偷吃时心情该有何等愉快。里屋的那位喵星人应该并没有打扰它的兴致。</p>
<p>关于房间结构与村落构造，Jian说的清楚明白，那也是那篇文章最动人的地方。多看了几遍，心里便有些微醺了。不得不叹服Jian的文字造诣。</p>
<p>可心刚刚化开，Jian就开始提到了人。</p>
<p>世界上的人，大体上分为两种人格。伟人和英雄——伟人是庸人的最高体现，而英雄，是必有一面极其超凡，始终不安太平的。而这个世界毕竟庸人众多，所以伟人往往取得最后的“胜利”，所谓胜者为王，历史上记载着一大串的伟人。而，这些人，真正的英雄都是看不上眼的。不谈化名的主人当初的决绝，我宁可理解成他心里英雄的种子发了芽，世俗的胜利，在他的心里，被古旧平淡的瓶瓶罐罐挤的没了位置。Jian和我也有这样的种子，而她想将之送给化名，而我偷偷藏到了阁楼。我俩都被莫名的暗流推到了通往伟人的路上，这条路像村里入夜后的羊肠小道，远处泛着幽冷的火光，看不到头。还记得那晚Jian面对这条路时紧张而急促的呼吸。</p>
<p>其实，在她身上，我能看到拜伦的影子。那是人类文化的最强音，反对权威，崇尚自由，绝对的个人自由。那是英雄之路的终极。</p>
<p>还说青瓦阁楼。</p>
<p>当地人多以经商为主，惯于敛财，这样的习惯集中表现在了天井上。整座楼房仅有天井一处采光，阳光满满的洒在天井里，像黄金；待到冬天雪季，白雪满满的落在天井里，像白银。这样的想象，是对钱财的意淫，充满着俗气。我倒是想象着雨天的天井，雨水滴落在天井里，听雨能听的无比真切，伸伸手就能感受雨水的清凉，而不至于被淋湿。真是恰到好处的设计，特别美。</p>
<p>但对天井仅限于想象，二进上三层的楼阁却是喜欢的真切。</p>
<p>那里，可以感受到四面八方的风，每扇窗都有不同的景致，或远山，或清池，绿绿葱葱，延绵天边。看得累了，就坐下，捡起几本古书，细细品读。那里，你的心可以十分的平静，可以安放得住，可以平躺。这时候，才能品鉴的出书中的古意，会心一笑，怡然自得。那里，你可以忘掉在世俗中的一切，唯有清风和明月。可以拉着你想拉着的手，呢喃，旖旎。那里，你的世界显得十分清晰分明，你能感受到自己的存在，你能确定，你是自己的王。</p>
<p>可是，阁楼若没有基石，岂不成了空中楼阁？底层的屋子，透着规矩，谨然的很，两侧对联，环抱着道义。对着厅堂，守着礼节，一切井然有序。静处在那里，甚至想象出清人的作揖，品茶，聊天，读书。“二字箴言惟勤惟俭，两条正路曰耕曰读”，Jian说，古人可选的道路无比明确。我脑海里却泛起功名利禄之独木桥上的悍然厮杀。</p>
<p>写到这里，就能看出此楼的隐喻。古人讲究内圣外王，固是一理。一楼接待来往宾客，处处是人情世故；阁楼作为独处之所，琴棋书画，是隐蔽的个人精神世界。要想保得住个人的小宇宙，既要做到<strong>世事练达</strong>，又要做到<strong>淡定通透</strong>。这都是修炼的功夫。</p>
<p>平静如镜，干净如水的青瓦阁楼，若是没有底下规规矩矩的支撑，恐怕只是镜花水月。</p>
<p>所以，青瓦阁楼是属于神的，底层的担当，高阁的隐逸，那早已不是凡人。</p>
<p>正如这里的主人，看似不流俗，极富个人魅力，可如果不是通晓人情，岂能在此村立足？干净的是山水，青石板掩盖了人与人之间卑劣的暗渠。</p>
<p>不如，你做青瓦，我做楼阁。成为各自的英雄，互补成神。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[井场实时数据采集器开发日志]]></title>
        <link href="work/about-collector"/>
        <published>2013-04-05T00:00:00.000Z</published>
        <updated>2013-04-05T00:00:00.000Z</updated>
        <id>work/about-collector</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>以前为了让DLL内部拥有更多的控制权，将采集间隔的控制放到了DLL中。但现在需要将实时数据显示出来，那么第一次调用DLL的时候，就无法立刻显示数据，而是需要等待一轮间隔时间。这就给用户造成一种很不灵敏的感觉。于是这次我将采<strong>集间隔的控制从新放回了DLL调用外部</strong>。</p>
<p>采集器的开发基本告一段落。这一次完全是速成式的开发节奏。虽然我很小心翼翼的力图让代码结构清晰，功能明确，小巧易改。但是最终，在我五一放假归来后，嗅到了代码的臭味。</p>
<p>是的，我的代码有了不好的味道。</p>
<p>起初，我的设想是，尽量开发可以复用的小模块，我开发完，别人也可以直接利用。而且力求一个模块只做好一件事，这是借鉴了UNIX思想的。可是我忽略了一个情况，我并没在Unix/Linux上开发项目，而是在windows。这就出现了很可笑的情况，我开发的小模块，看似灵活可拆分，实际呢，却没有人可以用。</p>
<p>问题首先暴露在界面上。人的一生有许多追悔莫及的事情，而这样的悔恨多来自于对坏习惯的熟视无睹，或是，每次都挑选简单熟悉的方式解决问题，即使明明知道那并非最好的解决方法。人总会向自己的惰性妥协。对于传统的C++程序员来说，MFC就是这样一个陋习。而我早知如此，却一直未能摆脱这段噩梦。</p>
<p>2011年我首次接触MFC，觉得还蛮新奇，毕竟除了Java Web以外，我并不知道该如何构建一个界面。不过我坦言，两年来，我虽然用MFC开发了好几个小程序，但仍然没有真正的学明白MFC。正是因为这样的原因，每当我发誓弃MFC而去的时候，总会有一个声音嘲笑自己：半途而废的东西，没真正明白一项技术，没有权利批驳它。</p>
<p>于是，我努力在<a href="http://www.codeproject.com/">codeproject</a>这样的网站上寻找开源项目来提升自己的见识和实力。一次又一次的优化自己手里的项目。毕设就不提了，完全是玩具项目。工作以来，接过师傅的VC6程序，就一直琢磨着改造。直到如今，简化到采集器这样简洁清晰，着实费了一阵功夫。但，两年以来，一直局限在MFC里无法自拔，逐渐就脱离了日新月异的技术浪潮。</p>
<p>但MFC真的无法解决很多问题：</p>
<ol>
<li>多文档太过重量级，除了大型的应用程序，不会用到。而在一个Web和移动应用盛行的今天，很难再有重头开发大型的桌面程序的机会了。基于对话框，我想是大多数人最经常的选择。而，即使是基于对话框，也需要循规蹈矩的生成一个千篇一律的框架结构，其中大部分东西都不会用到，MVC结构根本不清晰，大部分代码集中在V这层。结构很是冗余，而且生成代码过多导致修改起来十分费劲。</li>
<li>可用控件少的可怜，而且老化严重，比起同门师兄C#来说，既丑陋又贫困。VS2010里加了许多以MFC开头的特殊控件，想力挽狂澜，可惜用起来并不灵活，相关文档也很稀少。而且控件的绑定与之间的通信，都十分费劲。资源文件里一不小心就会有冲突。设计好的界面也很难有复用性，一般都是用打开的方式，复制rc文件。可是界面关联的逻辑和变量咋办？与已有界面元素冲突咋办？都能办，就是繁琐的很。往往复制来复制去，还不如重新拖拽一个。想做点界面美化的工作？别想了，费老劲还没个结果。</li>
<li>充斥着大量的个性方法，我承认，CString的很多方法都很好用，完胜std::string，但是很多底层的类都是用纯C++或纯C来写的。怎么结合呢？从效率角度思考，使用Unicode工程，好了，代码里各类W2A和A2W，仅字符串来讲，就会需要各种转换，弄熟悉了也觉得代码很乱。另外，MFC的容器真的很屎，完全无法与STL媲美。</li>
<li>跨平台是个大问题，不说Linux和Windows之间，就说Windows自己，在Win7下写出的程序，在XP或是win2003上完全走样。保守来说，不敢用太新的控件，否则总会出一些莫名其妙的问题。再说DLL，DLL很容易引起灾难的。稍微一个版本不一致，就会让整个应用程序不举。企图用DLL来让程序模块清晰，小巧玲珑，完全是个梦。而且MFC DLL真的很鸡肋，复用性如何考虑？纯C DLL要好很多，但是少了图形界面，很难实现界面组件化，随时可插拔。另外，移植性并不理想，VS2010编译的MFC程序，需要mfc的好几个dll，哦，你说为啥不编译成静态库？试试就知道，问题很多。</li>
<li>最让人难受的，还是MFC写的程序真的很容易发臭。我不知道如何描述这样的感觉，即使你在编写的时候，各种小心，力求清晰可修改。但真正需要你修改补充的时候，就寸步难行。不知道是咋回事。也不知道别人是否有这样的感觉。偶尔，你想着，这个功能我曾经写过，想抽出来，用到另一个工程中去，想着挺简单，不知不觉就会浪费好多时间。MFC的代码一点也不美，味道真的不好闻。</li>
</ol>
<p>以上五条，纯属个人吐槽，很多地方其实都是我自身的原因。但如果MFC是一个产品，我是一个用户，我就是不爱用，我想这是一个用户起码的权利。</p>
<p>我去年年底就发誓，配置小工具是我最后一个MFC作品，没想到今年又紧急开发了一个采集器。这绝对是最后一次了。</p>
<p>已经开始抽空学习QT了，QT的很多思维方式都很赞。虽然我还只是摸到了皮毛，但是已经嗅到了它的清香。</p>
<p>扯界面扯了这么远，其实界面只是一个因素。更可怕的是我误解了DLL。</p>
<p>采集器一共由五个DLL和一个EXE组成。EXE是主界面，用来呈现采集上来的数据。重要的功能全部分配到DLL身上来实现。五个DLL实现的分别是，连接服务器数据库，取得服务器数据库中的配置，采集仪器数据，处理仪器数据，将数据组织为WITS标准的UDP消息发送给服务器。取得配置DLL，主要替代了以前的配置小工具的功能，也完美的解决了XML、INI配置文件的繁琐。采集和处理DLL，主要继承了之前的DLL，改动不大，仅是简化。将打包DLL去掉，换成了发送的DLL，解决了共享的问题。</p>
<p>这样以来，程序结构看起来很清晰，每一个DLL干好自己的事情就行了。而且连接数据库和取得配置的DLL都是带界面的，属于具备MFC类的C Dll。我想着，这可以实现复用。还故意把接口弄成了读写文件形式，这样耦合度很低，即使没有DLL，EXE照样可以运转。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[写在2012的尽头]]></title>
        <link href="life/end-of-2012"/>
        <published>2012-12-31T00:00:00.000Z</published>
        <updated>2012-12-31T00:00:00.000Z</updated>
        <id>life/end-of-2012</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>年底总会写很多总结，学生时代为了给老师看，工作了是给领导看。什么时候才是给自己写的？以前总有这样的计划，直至今日，方才动笔。</p>
<h2 id="回忆">回忆</h2><p>1月份的时候，公司发了年终奖，还有一大堆福利，看到自己总算有了工资，心里难免会激动一场。而2011年的下半年，基本再为乔布斯而疯狂，于是，拉着Mr.Fox一起，走了一遭西单大悦城的Apple专卖店。经过一番劈天盖地的忽悠，我拎着一台iMac就回家了。那算是第一次与苹果亲密接触，趁着新鲜劲，赶紧买了一本Object-C基础教程。立志要能够写出自己的App，最后可以在商店上架。理想很丰满，现实很骨感。这本Object-C基础教程，除了第一章，之后都干净的很。原因是因为当时的工作任务，不怕不好意思，那时我第一次知道了用纯正的C++写类的感觉，而且还更进一步的写了一个基于观察者模式的框架。那种感觉实在爽到不行，再加上新来的组长是一个有20年C++编程经验的高手，于是乎我日日加班加点。苹果梦，不知不觉就淡忘了。</p>
<p>2月来的很快，那时我心有揣揣，领导突然安排我去西安出差。什么Object-C，什么观察者模式的消息队列，手还没有热乎，就要收拾行囊准备独自上路了。初到西安的时候极其不习惯，陌生的同事，完全不同的工作模式，我当时攒了一肚子怨气，于是搞砸了计划好的与北京同事的远程合作。那消息队列框架算是我来公司第一个像样的作品，却在襁褓之时就被告知放弃，这是如何也无法马上接受的。因此还差点和同事闹了矛盾。本月算是今年的第一次逆转，接收到两个教训：其一，工作要明确责任，做好自己的事情，不要老是盯着别人的活；其二，减少文字性聊天，如QQ，很容易产生理解性误会。</p>
<p>3月，人已在甘肃庆城县，遍眼的黄土还不算寂寞，荒野里住一宿也没有太意外。可是下旬近半个月没有和人类说一句话，的确有些难受。那段日子一个人在宾馆里，领导又没有切实的给我安排什么具体的任务，只好拿着一本Ruby入门开始学起了Ruby，当时，除了ios，最想学的就是ruby，没有很明确的目的，就是兴趣所致。当时还研究了好一会《番茄工作法》，但后来完全用不上，因为宾馆里除了睡就是吃，没有交流没有沟通，更不会有什么人会打断你。这里我漏掉了一环，从二月开始，我就想复习今年的考研了，对于一份这样的工作，我并没有找到做下去的意义，只是觉得读一读研究生可能会把一些事情想的更明白。于是二月还西安的时候，我就在当当网上买了很多考研复习的书籍，也很有计划的开始看高数和C语言了。三月上井，却没能带上这许多。这才彻底放开，去看Ruby的。</p>
<p>好不容易适应了孤独的日子，带我的师傅和以为年长的同事突然从现场赶回了庆阳。通知我一起去内蒙古的乌审旗，最后把我仍在了乌审旗的一个井场上，呆了四天的时间。井场上那带沙的饭和数的过来的几个冷菜，我都已经熟悉了。甚至连录井房的那几位技术员也聊得很开，但这样的日子毕竟过的荒诞，期间我多次催促项目组来接我下去，现在想想其实真没必要。后来项目组把我带回了乌审旗，我独自走在陌生的内蒙风情的大街上，心里只想着赶紧回家。回西安的大巴很颠簸，我中途拉了肚子，但由于车在高速上跑，没有办法停，只好忍了一路，只记得下车时的无比狼狈。</p>
<p>4月已经在西安，当时有点旅游控，就想着走天涯，去远方，独自远行之类的。于是总算在西安市内好好转了转，陕西历史博物馆给了我很深的印象。从小对有历史的东西就有莫名的痴迷，在不算大的博物馆里，从上午9点一直待到了12点多，出来时才感觉到了饿感，才在门口吃了一碗牛肉面。之后就去了大雁塔、慈恩寺，沉浸在自己营造的诗情画意中，倒也心满意足。这个月对于考研的坚持就没有那么的强烈了，对于网上各种新潮的技术都有了兴趣，看看这瞧瞧那，没个定性。但一个同事启发了我对于octopress的认识，那算是我第一次动手倒腾极客的事，这才诞生了这么一个简陋的个人Blog，不管怎么说，都很开心，中间由于公司内网的障碍，也遇到挺多的问题，但都一一解决掉了。这个月，让我在技术上的眼界更加的开阔了，风格上也更加的大胆激进了些，不管懂不懂，动手试试再说。下旬，西安的领导让我改进师傅的程序，我也恰有此意，当时我只是想尝试用自己的方式来重新实现师傅的程序（其中很大的原因是我不愿意在用VC6那样碍眼的编辑器了。。。），但我设想的有点太大，几乎把我见过的技术全都想用一遍，于是这个程序就演变成了一个具备socket传输、打包服务、全套的XML配置等的小框架，基本呈现一个C/S模式。但由于技术不精，交流不畅，与另一个负责远传的同事发生了一些激烈的争吵，这个小框架虽然被我自豪的上传了github，但最终还是不了了之了。可是，这个小框架算是我第一次肆无忌惮的独立设计，期间对很多的小工具与C++编程的思路都有了很好的沉淀，为下半年设计井场数据采集中间件流水线框架打下了坚实的基础。4月算是一个技术提升月。</p>
<p>5月的开头，为了满足自己的旅游梦，与师傅和另外一个同事一起，走了一趟洛阳和嵩山少林寺。地方俗得很，但玩的很舒服，至少爬山算是爬爽了。第一次对山间清新的空气有了无比的迷恋，深深的厌恶都市里充斥尾气的环境。旅游的确能让人明白许多事，能让人放开很多事，但也不知不觉花了许多钱。有失有得吧，但总算有些缓解了我对于旅游那种极度浪漫主义的渴望。就那么回事吧，山清水美又能怎样，关键是你与谁携手。回来后，立刻就收到了上井通知，这一去就是半年的旅程。</p>
<p>5、6月我遇见了很多人，要比我以前一两年遇到的人都多，也遇到了许多事，让我这娇生惯养的小皇帝体验了一把劳动人民的艰辛。这里不得不提一下遇到的极品同事王小贱，这位纯正的90后是第一次上井，但却有着丰富的江湖经验。早年就和我师傅一起在阳台上抽过烟，所以这次并没有太多生涩的感觉。小贱对于生活的理解及其简单，吃喝玩乐一样也不能少，年纪轻轻，对于嫖赌已经见怪不怪。从他身上，我顿时觉得自己有点白活，十几年的学校生涯，让我并不知道外面的世界原来有这样多的花样，遇到他简单至极的生活理念，我一肚子的思想道理也无处倾泻。但小贱这样玩得转的人，是不会屈膝做一些具体事情的，师傅也没理由动手，于是在井上，我满头大汗跑东跑西，又是抬箱子又是埋网线，上至房顶，下至床下，左手U盘，右手签单，嘴里还要给技术员们培训。只记得那段日子很痛苦，却又没法诉苦，只能小心翼翼的配合。而他们却照常嘲笑我在车上重重的鼾声，急急忙忙的小便。这些只是小事，但小贱对于报销上玩的手段却让初涉社会的我猝不及防。不管怎么说，这两个月里，我知道了太多社会上的事情，我眼见着认识三天的人称兄道弟酒醒酒醉，我也明白了一根烟、一杯酒竟能轻轻松松破除人与人之间的隔阂。小贱如果不是对于小钱小利太过猴急，我甚至看不清他的真实面孔。这让我知道，出门靠朋友，但更要靠自己。</p>
<p>6、7月，上井已经成了家常便饭，在外漂泊的日子算是倦了，认识的新同事越来越多。老江湖去玩女人，屌丝儿只好dota。那一段日子除了修改程序时的充实感外，灯红酒绿、觥筹交错与11平台上的开黑都让我事后倍感空虚。所谓闲，就是在宾馆里一起抱怨工作一起想家；所谓忙，无非就是陪领导喝酒侃大山，给领导交报告，满足领导天马行空的需求。但也不能算是完全荒废，起码我学会了在外如何与别人相处，如何游离在亲密与疏远的中间地带。如何与那些社会上的老油条们谨慎相处。如何凝聚自己所在的团队等。但核心还是想家，厌倦了东飘西荡的感觉。</p>
<p>8月份基本已经确定了回京的事宜，月初从北京休假归来，在西安感受到了强烈的寂寞感，还好一位帅哥同事友情援助让我安稳度过一晚。第二天坐上到延安的高铁，再坐大巴到了志丹与师傅们会和，但很快师傅就已经离去。独留我一个人带队实施。那段日子还是挺有成就感的，因为完全由我来安排一切，当时我积极的改版新程序，同时也积极的辗转陕北到处上井。从志丹到吴起，从吴起到安塞，又从安塞抵达靖边，一路上结交了许多当地项目组的人。曾经青涩稚嫩的我也能装模作样的游刃有余于合作与交流中。由于队员与司机的疲惫，我只好一个人上路，再次乘坐大巴去了定边的冯地坑与另一个小队汇合，在那里才认识了<a href="http://www.cnxp.org">冰魂网络</a>的站长IceSoul，这家伙年过三十还打着光棍，却还自娱自乐的玩弄着各种小技术，是个标准的极客+屌丝。从他那里，很多对于windows系统方面一知半解的知识都得到了验证和解释。他早年编写的许多小工具都让我大开眼界，也算是我在现实中第一个遇到的偏骇客的家伙了。那段日子有趣极了，我们每到一个旅馆，都将旅馆的路由器进行整改，以保证我们房间能够有足够的网速来dota。但并非每一次都能得逞，最后在庆阳的时候，我们摸到了人家的视频监控系统，却没能破解了其密码，确是遗憾。在他的催促下，我将井场自动采集软件做了最后的整改，配合他编写的配置小工具，倒是相得益彰。</p>
<p>8月绝对是神奇的一个月，除了上述的辗转陕北与到处捣蛋，竟还莫名其妙的遇到了我生命里的冤家，刚认识她的那几天，每天我都像打了鸡血一样，抱着心爱的iPad和她胡天海地的聊着，用我妈的话来说，就是把她和我爸一辈子的话都在那几天内说完了。现在想起来，会觉得滑稽，捧着一个iPad不玩游戏不看电影不看电子书，只用iMessage和一个不曾谋面的女孩聊天。实在奇葩的很。不知道哪里来的自信，和她聊完的第二天，我就有强烈的把握可以搞定她（可是这样的感觉并未持续很久）。正是因为这隐隐约约的暧昧情迷，才会出现上文所述那种需要别人催促才去编程的尴尬状况。写到这里突然不愿意多回忆关于她的点滴，因为每一天都记得十分清晰，从8月19日的第一封短信开始，直到如今。这并不需要总结，更不需要——回忆。就像阿里巴巴得到了四十大盗的宝贝，尽管情不自禁的让大门露出了一点缝隙，但立刻就会掩上，生怕别人知晓了去。</p>
<p>9月的第一天，我已经在北京上班了。从微博的数量就能看出来那阵子我的兴奋，爱情工作友情，重新回到了我的生命里，让寂寥的荒野，硬是长出了青苗。但爱情里有甜蜜势必就有苦涩，白璧微瑕更像是真实，娇艳的花朵总需要有破壳的过程，痛过方知不易，失去才知珍惜。月底更显忙乱，略去流水，算是留白吧。</p>
<p>10月初，去了一次舟山，参加表哥的婚礼。乱糟糟的幸福充斥着难闻的气味，我并未留下太多好的记忆，倒是后来去老家山上待的那几夜，映着月光在屋顶通电话的静谧让我难忘。青山绿水，流转着浓郁的思念。粗茶淡饭，消磨着转瞬的悲欢。梦里总会出现很多的如果，如果这样，如果那样。但最后还是要坚强的面对现实，学会理解，放下虚幻。</p>
<p>10月后的日子，重新投入到了工作中，凭借着一年的技术积累与实践经验，总算在一个月内，完成了对师傅采集程序的重构，并远远超出了原有程序的架构，运用了我所了解的全部技术。那段日子在工作上过的十分骄傲，数据采集流水线框架，成了我真正意义上的一个产品，一个实用的作品。那段时间总认为自己可以改变世界，正在改变世界，其实实事求是的说，我仅仅是沉淀了以往所有的技术积累，数据库，字符串处理，XML，INI，动态链接库。这些只不过是一个C++程序员的基本功而已，并不值得一提。网络、图形图像、并发处理，这些经典的领域还很遥远。可无论如何，我从中获得了满足与快乐，享受着这段不断实现想法的日子。</p>
<p>11月到12月，中途弄了阵Java，因为两位同事的调离，所以接替了他们的程序。并未感觉多么陌生，反而重新有了兴趣。甚至在网上找到一个很棒的SWING框架，琢磨了好几天后，突然发现它价格不菲，于是果断放弃了。又有几次开会推翻了之前的想法，一心要用什么ActiveX来做伪B/S。无奈我只好改用熟悉的MFC来迎接变化。轮到自己设计人机交互的程序了，才明白界面设计有多么的力不从心。我们只是程序员，哪来的美工那样挥手即来的艺术灵感。庆幸的是在今年的最后一天，这个采集配置器的小工具总算成型。我保证，这将是我最后一个MFC作品。。。</p>
<h1 id="总结">总结</h1><p>许是恋爱谈久了，写的文字又臭又长。在她面前小心翼翼不敢乱说话，自己写起来就各种大白话，不加修饰。能有耐心看到这里的，怕是只有我自己了吧。</p>
<p>总体来说，2012比2011过的更加奇幻，更加的有意义。有心摘的花没开，无心插的柳成荫。世事无常，人生无解。</p>
<p>最后废话几句吧：</p>
<ol>
<li>彻底阉割了考研梦，国内的研究生学习不值得向往，将目光聚焦大洋彼岸。</li>
<li>借用某人的话，研究技术不要秒射，年初的ios和ruby都是一时心血来潮之举。4月搞了一阵子C也是三天打鱼。要不是工作原因，C++都不会得到应有的沉淀。</li>
<li>工作了就不要和学生那样思维单纯，说话做事之前多想想，人际关系很微妙。守住底线，摈弃固执，沉住气，用心去理解。</li>
<li>不仅仅是技术，下半年回京后的英语、跑步都有间断，人最难对付的是懒惰。</li>
<li>仅发烧了两次，值得表扬，运动不能弃，身体最关键。</li>
<li>爱情，是顺其自然。</li>
<li>工作讲究划分责任，多听少说，多做少怨。注意积累工作经验与方法。</li>
<li>QQ交流最没效率，容易误会容易激动容易伤人，请拿起手边闲置的电话。</li>
<li>少说那么多道理，放下身段，听听别人怎么说，看看别人怎么活。</li>
</ol>
<h1 id="明年关键词">明年关键词</h1><p><strong>专注</strong>，<strong>坚持</strong>，<strong>放低自己</strong> ，<strong>大胆去做</strong>，<strong>沉住气</strong>。</p>
<p><em>英语要听</em>，<em>托福</em>，<em>C</em>，<em>学习前台网页设计</em>，<em>C++的基础</em>，<em>操作系统与网络</em>。</p>
<p>最后，但最重要：</p>
<blockquote>
<p>她</p>
</blockquote>
<p>&lt;--全文完--&gt;</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[相信，救世主与问答]]></title>
        <link href="essay/life-of-pi"/>
        <published>2012-12-18T00:00:00.000Z</published>
        <updated>2012-12-18T00:00:00.000Z</updated>
        <id>essay/life-of-pi</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/PI.jpeg" alt="PI"></p>
<p><code>此文严重剧透，没看过这部电影请自觉飘过。</code></p>
<!--more-->

<h2 id="相信">相信</h2><p><strong>这是一个关于相信的故事</strong>。</p>
<p>我是<em>上周四</em>看的这部电影，看完之后有感动，感慨和欣慰。这并非是一部依靠情节的作品，所以我选择在遗忘的差不多的时候，开始拾起。
<strong>往往此刻还能记起的，才是真正值得思考的东西。</strong></p>
<h4 id="信仰">信仰</h4><p>派小时候有很多<strong>信仰</strong>，如最初的<em>印度教</em>，那是一个成千上万个神存在的世界，也许派只是好奇为何有这样那样的神存在。后来的<em>基督教</em>，是一杯水的故事，派只是去偷水，没想到还获得了信仰。派有了许多信仰，我现在能记起来的也就上面两个，但我能确定的是，貌似他没有信仰<em>道教</em>。不过我也相信，如果有人引导他，他也会相信。</p>
<p>清楚的记得他的疑问：<strong>耶稣是神的儿子，神为何让耶稣来人世间承受这样那样的苦难？</strong></p>
<p>派开始祷告，在每顿饭之前，即使不被父亲理解。</p>
<p>信仰好像给了派一种力量，这种力量让派敢于去直视老虎的眼睛。<strong>父亲说，对着老虎的眼睛，你什么也看不到，只能看到自己的影子。</strong>看到这里我偷偷笑了笑，派的父亲因为科学的力量治好的顽疾，于是至此之后成了科学的脑残粉。我相信，当时的派是能看到除了自己影子意外其他的东西的。这种东西正是我们现代人极其缺失的。<strong>或许我们应该称之为灵魂？</strong></p>
<p>父亲不留情面的牵出了小羊羔，给少年派留下了一段血腥的回忆。父亲想说，别跟我扯那些虚的，动物就是动物，只有<strong>弱肉强食</strong>。我的父亲从小也经常对我说这句话，这的确是真理，附带着冷冰冰的刺痛，多少次把我从幻想中扯醒。</p>
<p>于是，科学，真相，与血腥，让少年派失去了第一个东西，姑且称之为<strong>信仰</strong>。有人会说，没有啊，后来他还是信这信那，随处祷告的。但请细细体会，多多少少有些牵强。</p>
<h4 id="爱情">爱情</h4><p>不知道那能不能算是爱情，打鼓的派，盯着跳舞的姑娘一动不动。每一个人都会有这样一个震撼的时刻，<strong>美</strong>，突然的降临，猝不及防。派是幸运的，他表达出来了自己的喜欢，两个人貌似也走到了一起。但好景不长，派一家因为要离开印度，远洋去往加拿大，所以有了不可避免的分离。</p>
<p>特别喜欢两个人最后的时光，细细的看，那个女孩身上有着神圣的光芒，嘘，每个男生都会有这样的情节，那是一种比爱情更加圣洁的情感，正如，金庸迟暮之年才明白过来，原来段誉对王语嫣并不是爱情，慌慌张张的改写了结局。</p>
<p>派在船板上伤感离别那一段，看着让人心碎。</p>
<p>少年派失去了第二样东西，我们勉强称为<strong>“爱情”</strong>。</p>
<h4 id="亲情">亲情</h4><p>父亲对派一直很严厉的样子，但派还是在举家搬迁之际，感受到了父亲的无力。因为厨子对派母亲信仰的戏谑，父亲发了怒气，之后派在臭气冲天的甲板下动物仓库内遇到了正在给鬣狗打安眠药的父亲，那个给父亲的镜头让人看了心酸，疲惫不堪又努力掩饰失落的表情，处处体现着父亲的衰老。这里有一个绝妙的暗喻，父亲刚刚教训的厨子，正是奇幻飘旅中的鬣狗，父亲在时，厨子尚能压抑心中的兽性，而父亲的离去，正好对应着鬣狗药性的消退。</p>
<p>派的哥哥也是一个很可爱的角色，即使是独生子女，小时候也会有这样一个玩伴，每当你想去玩啥的时候总会拉上他，派的哥哥连老虎都陪着派去看了，可是那晚暴风雨的夜，派怎么拉他也没拉醒。派在暴风雨里疯狂的跳着舞，哥哥呢？我们不知道，后来也永远没法知道了。</p>
<p>派莫名其妙的被扔到救生船的刹那，他失去了第三样东西，<strong>亲情</strong>。</p>
<h4 id="遗失的一环">遗失的一环</h4><p>细心的读者会发现我漏掉了一环，派名字的得来，电影的一开始，作家开始发问，<strong>听说你有一个故事能让我相信上帝？</strong>然后派就开始讲述他的本名，典出一个游泳池，这也交代了派对于水的熟悉，为后面的故事埋下伏笔。噢，我并不是要讲他那发音类似<em>小便</em>的名字，但，这样的经历，是否让我们似曾相识？小时候，我们总会伴随着一些嘲笑成长，那就是小孩子的世界，觉得好玩就会笑，对于大部分美满家庭长大的孩子来说，这算是人生第一个艰难的时刻，每个人都需要勇气去面对，去改变。当派在黑板上写下那长长的小数时，你有没有会心一笑？</p>
<p>我们的好成绩，我们的好强，我们的优秀，最初，是不是仅仅为了不被嘲笑呢？</p>
<p>镜头停止在了派最后长长舒了一口气。那是派建立自信心的开端。在此之后，才有了之前说的信仰。<strong>那些整的你痛苦不堪，死去活来的日子，有种东西正拉着你飞速的成长。</strong></p>
<p>写到这里，会不会忽然有所悟？少年派的奇幻飘旅之前，那些断断续续，看似可有可无，还有点搞笑的回忆到底有什么作用？</p>
<blockquote>
<p>我们在关注到底应该相信哪一个故事时候，有没有回过头想一想之前的故事？关于<code>幸福</code>的故事？</p>
</blockquote>
<p><strong>幸福？</strong>为什么这样说？人生最宝贵的东西是什么？如派一样，第一次证明自己，被他人认可？被玩伴戏弄，却因祸得福，对于一些模模糊糊的道理突然怀疑又突然的相信？第一次单纯的相信世界的美好，却被狠狠的泼了冷水，被迫接受现实？不经意间遭遇了怦然心动，却又忽而分离？总有一个瞬间，忽然感受到强大不可被战胜的父亲显露疲态，凸显衰老？哦，别忘了，经历上述这些的时候，总有一个人紧紧的抱着你、陪着你到最后，直到她也离去。</p>
<p>她，母亲，也离去的时候，派已经开始与老虎、斑马、猩猩、鬣狗一起在海洋里漂流了。</p>
<p><strong>在此之前，你要相信，那是我们都曾经历过的生活，是最彻底的幸福。</strong></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Reflection In Cpp]]></title>
        <link href="study/call-function-by-name"/>
        <published>2012-12-11T15:22:00.000Z</published>
        <updated>2012-12-11T15:22:00.000Z</updated>
        <id>study/call-function-by-name</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>今天项目中需要通过读取数据库中的字符串，由字符串的值来确定调用哪一个方法来进行操作。我们不可避免的需要写if语句来匹配字符串，然后调用相应的函数。</p>
<blockquote>
<p>实际上在windows上，更方便而高效的是将要调用的方法都写在dll中，但项目进行到这个阶段，那些成群结队的方法早已经写好，封装成类，且被多个模块调用着，如果将之提取到dll，避免不了有大面积修改。于是，我只好尝试采用最笨拙的方法。</p>
</blockquote>
<p>其实，有点回调函数的意思。大家说说呢？</p>
<p>看代码吧：</p>
<div class="highlight"><pre><code class="cpp"><span class="comment">//</span>
<span class="comment">//  main.cpp</span>
<span class="comment">//  NameTodo</span>
<span class="comment">//</span>
<span class="comment">//  Created by pezy on 12-12-11.</span>
<span class="comment">//  Copyright (c) 2012 PEZY. All rights reserved.</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> fun1(<span class="keyword">void</span>)
{
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"function 1:\"int fun1(void)\" is called"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">1</span>;
}

<span class="keyword">int</span> fun2(<span class="keyword">void</span>)
{
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"function 2:\"int fun2(void)\" is called"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">2</span>;
}

<span class="keyword">int</span> fun3(<span class="keyword">void</span>)
{
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"function 3:\"int fun3(void)\" is called"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">3</span>;
}

<span class="keyword">typedef</span> <span class="keyword">int</span> (*fun_ptr_t)(<span class="keyword">void</span>);

<span class="keyword">typedef</span> <span class="keyword">struct</span> str_fun_t
{
    <span class="built_in">string</span> name;
    fun_ptr_t ptr;
}str_fun_t;

<span class="keyword">void</span> bind(str_fun_t *key, <span class="built_in">string</span> name)
{
    <span class="keyword">static</span> str_fun_t str_fun_array[]=
    {
        {<span class="string">"fun1"</span>,fun1},{<span class="string">"fun2"</span>,fun2},{<span class="string">"fun3"</span>,fun3}
    };

    <span class="keyword">int</span> i;
    key-&gt;name = name;
    key-&gt;ptr = NULL;

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str_fun_array)/<span class="keyword">sizeof</span>(str_fun_t); i++)
    {
        <span class="keyword">if</span> (key-&gt;name == str_fun_array[i].name) {
            key-&gt;ptr = str_fun_array[i].ptr;
            <span class="keyword">break</span>;
        }
    }
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])
{

    <span class="comment">// insert code here...</span>
    <span class="built_in">string</span> name(<span class="string">""</span>);
    str_fun_t key;

    <span class="built_in">cout</span> &lt;&lt; <span class="string">"your function name:"</span> &lt;&lt; endl;
    <span class="built_in">cin</span> &gt;&gt; name;
    bind(&amp;key,name);
    <span class="keyword">if</span>(key.ptr)
        key.ptr();
    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"the function "</span> &lt;&lt; key.name &lt;&lt; <span class="string">" can not be found"</span> &lt;&lt; endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre></div><p>运行结果：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/result.png" alt="result"></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[乌审旗的夜]]></title>
        <link href="life/night-in-wushenqi"/>
        <published>2012-05-19T13:55:00.000Z</published>
        <updated>2012-05-19T13:55:00.000Z</updated>
        <id>life/night-in-wushenqi</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <blockquote>
<p>乌审旗，五马路附近，傍晚，微风。</p>
</blockquote>
<p>本来只是出去走走，但走到冷清处，忽然很想跑步。</p>
<p>一位蒙古族的老人，静坐在这不知名的广场上，天很暗，看不清她脸上的神色，也许仅是疲乏了。但加上了我的想象，只感觉无比虔诚，万籁俱寂。又跑了一会，看见，一位街道保洁服装的女人站在道牙子上，拥抱着一个骑着摩托的小伙子。是述说心事，是表达爱意，还是倾听悲伤？在我的眼里，恰是一幅小城风情的油画，不同的人，能从其中看到不同的故事。</p>
<p>今天的文字写的很慢，因为忽然觉得我善于抒情说理，并不善于描述渲染。文字缺乏现实的力度，少了观察的功夫，属于言之无物，有些说教的意味。</p>
<p>来到这个陌生的城市，遇到很多困难，受了很多委屈，我努力的不让自己在文字里抱怨。尽量展现我所看到的真实世界，活生生的人。也许在象牙塔里待得太久，陷得太深。习惯与书中人交流，面对赤裸裸的人性，却显得有些生疏尴尬。</p>
<p>多观察、多思考，也许是浮躁的太久，需要多一些经历来沉淀。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[加班与效率]]></title>
        <link href="work/summary"/>
        <published>2012-05-04T13:15:00.000Z</published>
        <updated>2012-05-04T13:15:00.000Z</updated>
        <id>work/summary</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>这一周玩的疯狂，工作也疯狂。</p>
<p>去了洛阳以及少林寺，本来有很多感悟，很想好好的写一写。无奈回来就被告知下周要上井，尽快拿出程序。某同事还添油加醋的说，谁让你以前老不干正事，这下着急有啥用？</p>
<p>这话一下戳中了我的死穴，来西安的这么多天里，工作上的确松懈了很多，连周报也懒得写了。总想用工作的时间来提升自己的能力，能力包括了很多方面，单调的工作自然无法适应我的需求了。这下子被人拿到了把柄，真是有理说不清了。</p>
<p>于是奋斗了三四天。基本就是除了工作就是吃饭睡觉。</p>
<p>今天师父说了一句话，<strong>加班有啥用啊，关键是效率。</strong></p>
<p>师父的确很有效率，如果程序出现什么问题(在现场)，他总会很快的找到问题所在，并且在至多半个小时内解决掉。这其中的奥妙不足以向外人道也。身边人只觉得他聪明而已。</p>
<blockquote>
<p>什么是效率呢？</p>
</blockquote>
<p>师父虽然能在短时间内解决掉bug，或是很快的给程序加上某项功能。但同时也让程序更难以被他人读懂，甚至修改。因为灵机一动想出的方案，或是现场使用过程中遇到的特殊情况，是坐在办公室的程序员很难去理解的。唯一的交流途径就是代码而已，因为效率，代码没有注释；因为效率，代码匆匆写过；因为效率，那些特殊情况无法向外人道，只要当时能够解决就行。因为效率，却苦了后人。</p>
<blockquote>
<p>工作难道就应该这样吗？</p>
</blockquote>
<p>我理解的效率却有些不同，我希望多花一点时间，提高代码的可读性、可维护性，降低各部分的耦合性，描述特殊的场景。希望自己花掉的时间，不再让别人重复去花掉，甚至不会让自己日后再重复花掉。但这样，却苦了我，需要考虑更合理的技术，需要考虑耦合度低的架构。需要花更多的时间重构，需要花更多的时间测试。细细雕琢自己的产品，让它真的成为一种工艺。</p>
<p>也许是性格所致，读书的时候我就是这样的。别人以考试为最终目的，为了效率，甚至不需理解科目的内容，只需要技巧与突击复习。我却会花掉大量时间去真正的学习其内容，按照前人的方法去深入挖掘，认为考试只是一种巩固的手段。结果别人榜上有名，我却名落孙山。当时我安慰自己，没事，工作之后就不会有这样的情况。但，如今工作了，还是效率。</p>
<p>在忙碌，或毫无头绪的时候，我容易怀疑自己，更严重者，会迷失自我。会对曾经坚信不疑的想法重新审查。聪明的同事说，你说的这些问题，我在小学就开始思考了。其实，我何曾不是呢，但因为反复的思索，反复的怀疑，反复的迷失。我总会在人生的各个阶段，重新的去获得结论。我不是一个坚定的人，容易摇摆不定，容易失去信心。从人生的长度上看，这是否也是一种低效呢？</p>
<blockquote>
<p>没了信心，何谈信念；不谈信念，无关信仰。</p>
</blockquote>
<p>这个世界很难有一个统一的标准，很难有人能够真正的告诉我，什么才是<strong>“对”的事情</strong>。总是在不断的摸索，做自己认为合理的人。</p>
<p>到底应该用何种方式去工作，判断是否成功到底应该遵循怎样的标准。这些都关乎人生价值，人生意义。</p>
<p>大家都是怎样想的呢？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[抱怨]]></title>
        <link href="life/complain"/>
        <published>2012-04-27T13:56:00.000Z</published>
        <updated>2012-04-27T13:56:00.000Z</updated>
        <id>life/complain</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p><em>既然这个博客没有人看，不如自己写一些自己的心事。</em></p>
<p>今天不知怎么了，因为小妹很平常的一句抱怨，心里就异常的烦躁。平时并没有这样小心眼过，只是突然觉得，自己是不是多事了呢？是不是又关心则乱了呢？是不是一直都说着同样腔调的话，惹人厌了呢？我不知道。</p>
<p>我觉得世上最让人难受的就是：</p>
<ul>
<li>臭着一张脸给别人看(胡适语)</li>
<li>无时无刻的抱怨烦躁</li>
</ul>
<p>现在我甚至觉得这是<strong>耍流氓</strong>，虽然以前我也曾这样干过，但只有在经历了别人对自己做过之后，才能深刻的体会这一点。“己所不欲，勿施于人”。我以后一定不要再犯了。</p>
<blockquote>
<p>其实真的有那么多可以烦躁的事情吗？真的需要不断地抱怨吗？</p>
</blockquote>
<p>我经常看两个博客，一个偏重心灵的<a href="http://www.zreading.cn/">左岸读书</a>，另一个是偏重技术的<a href="http://www.coolshell.cn/">酷壳</a>。这两个博客总会在我异常浮躁的时候，渐渐让我踏实。</p>
<p>譬如，我会想不通人生的意义，会在帮助不了妹妹们、同事们而感觉到无力，会在工作上碰到技术难题时萎靡，会在面对渺茫的前途时不安，会在一个人孤独工作时寂寞，会在被前女友骂的狗血喷头时茫然无措，会在羡慕同事种种优秀时独自忧伤，会在爸妈的抱怨中内疚自责。</p>
<p>我想，人生在世，每个人都会有自己的烦恼和忧伤，这都是生活的一部分而已，如何看待才是最重要的。</p>
<p><strong>想想看，我们真的应该去抱怨吗？</strong></p>
<p>想不明白人生的意义，就应该更加大胆努力的去体验生活，跟不同类型的人交流沟通。帮助不了别人，就努力的帮助自己。只有自己不断的成长，才能够有能力帮到他人。</p>
<p>工作时遇到难题，或是觉得自己并没有在做自己想做的事情，这没关系，好好规划时间，抓紧效率，不要高估自己，自己的实力绝对还没有到能够碰见解决不了之问题的境界。</p>
<p>前途渺茫，更加应该好好把握当下，而不是去浪费时间抱怨、听歌、随意的在网上闲逛、无目的的看电影、找乐子、甚至是选择在游玩中忘掉烦恼。(这绝对可笑之极，详见<a href="http://blog.sina.com.cn/s/blog_5eb3aea50100h5kx.html">这里</a>)</p>
<p>感到寂寞，不如享受孤独。只有独自一人，静下心来好好思考，才能够想明白道理。</p>
<p>被女友骂，或是别人说了难听恶毒的话，那就像产生的垃圾一样，应该倾倒掉，而不是被你接住，继续传染。要知道那些都是肮脏的东西，清者自清，何必在意。</p>
<p>同事优秀，也要知道自己有没有在自己的优秀之处更进一步，有没有因为自己的优秀之处而炫耀自得？见贤思齐焉，见不贤而内自省也。吸取其优秀之处，同时也要更加注意谦虚。</p>
<p>爸妈爱说自己没出息，不妨化作前进的动力。要知道，无论如何，他们心里永远会为你而骄傲。</p>
<p><strong>看似都是烦心事，其实一件也不值得去烦恼。</strong></p>
<blockquote>
<p>世上本无事，庸人自扰之。</p>
</blockquote>
<hr>
<p><em>抱怨无异，不妨花时间反思一下。</em></p>
<p>目前自己最需要在两个方面提高：</p>
<ol>
<li>学会克制</li>
<li>学会规划</li>
</ol>
<blockquote>
<p>“限制产生力量，自由导向死亡。”(达芬奇语)</p>
</blockquote>
<p>克制自己的欲望，克制自己的懒散。虽说封建社会对于人有太多的约束，而近现代以降，却又显得<strong>矫枉过正</strong>了。还是那句话，我们的社会开始异常的浮躁，底线与原则越来越容易被打破。这将是一种可怕的弊病，如果研究过罗马帝国史，就该吸取一些教训。“忧劳以兴国，逸豫以忘身”，“玩物丧志”，古人并非完全是被社会所约束，其实还有许多的克制是因为祖祖辈辈的教训。不要以为现在人人都喊着“民主自由”，就可以“随随便便，任意妄为”了。</p>
<p>规划之重要，只有在措手不及之时才能深刻地体会到。凡事要想在前面，准备在前面，甚至做在前面。不要拖延，不要无视计划，不要在不恰当的时间做不恰当的事情。规划其实本质在于执行，这就需要克制的作用。只有彻底能够克制自己，话句话说，就是能够控制自己，不为情绪所左右，才能够规划自己的未来。散漫随性，或许诗意情趣，但需要时刻准备接受命运给予的跌宕起伏。如何选择，自己负责。</p>
<p><strong>是不是我写的东西都很像说教呢？</strong></p>
<p>其实大多数情况下，我都是在为自己说教，很多事情短时间内是想不清楚的，最有效的方式，就是先吸取前人的经验，去大胆的尝试。如果听不进前人的经验，自己原地迷惑抱怨，我想完全是在浪费生命。小学都学过《小马过河》，不亲自试试，如何知道水深水浅呢？</p>
<p><strong>少谈一些情绪，多谈一些问题吧！</strong></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[VC处理XML的方法]]></title>
        <link href="study/vc-process-xml"/>
        <published>2012-04-25T00:54:00.000Z</published>
        <updated>2012-04-25T00:54:00.000Z</updated>
        <id>study/vc-process-xml</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>目前调研到两种比较好的方法：<code>CMarkup</code>和<code>TinyXML-2</code>。</p>
<p>以下是两者分别的文档：<a href="http://www.firstobject.com/dn_markupmethods.htm">CMarkup</a>，<a href="http://www.grinninglizard.com/tinyxml2docs/index.html">TinyXML-2</a></p>
<p>从上手的难易程度来看，目前偏向于使用<code>CMarkup</code>，不过有机会一定要研究一下<code>TinyXML-2</code>的使用，目前关于<code>TinyXML-2</code>的中文资料较少，正好花时间翻译整理一下。另外，它不仅开源，而且功能较<code>CMarkup</code>要全面，文档更加齐全。</p>
<p>下面首先说一下<code>CMarkup</code>的基本使用方法：</p>
<p>首先在<a href="http://www.firstobject.com/dn_markupmethods.htm">这里</a>下载<code>CMarkup</code>，里面包含一个<code>Markup.h</code>和<code>Markup.cpp</code>。分别引入自己的项目下。</p>
<p><strong>NOTE:</strong> 貌似<code>CMarkup</code>仅支持MFC，在控制台程序中似乎无法使用。</p>
<p>在引入之后，需在在<code>Markup.cpp</code>的头部加上<code>#include &quot;stdafx.h&quot;</code>，在下述<code>testXML</code>工程里，不再赘述这一过程。</p>
<h2 id="创建xml">创建XML</h2><ol>
<li>新建一个MFC工程(<code>testXML</code>)，选择基于对话框的就好，其余一切默认。</li>
<li>在对话框上新建一个按钮(<code>Create</code>)，添加<code>BN_CLICKED</code>控件事件。</li>
<li>在事件函数中写入一下代码：</li>
</ol>
<div class="highlight"><pre><code class="cpp"><span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtmCreate()
{
    <span class="comment">// 创建XML</span>
    CMarkup xml;
    xml.AddElem( L<span class="string">"ORDER"</span> );
    xml.IntoElem();
    xml.AddElem( L<span class="string">"ITEM"</span> );
    xml.IntoElem();
    xml.AddElem( L<span class="string">"SN"</span>, L<span class="string">"132487A-J"</span> );
    xml.AddElem( L<span class="string">"NAME"</span>, L<span class="string">"crank casing"</span> );
    xml.AddElem( L<span class="string">"QTY"</span>, L<span class="string">"1"</span> );

    xml.Save( L<span class="string">"F:\\Sample.xml"</span> );
    MessageBox(L<span class="string">"Success!"</span>);
}</code></pre></div><p>我们仅运用了两种方法：<a href="http://www.firstobject.com/dn_markAddElem.htm">AddElem</a>和<a href="http://www.firstobject.com/dn_markIntoElem.htm">IntoElem</a>，前者可以理解为增加一个标签，后者则是进入此标签，很简单的逻辑。</p>
<p>以下就是生成的XML示例：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">ORDER</span>&gt;</span>
<span class="tag">&lt;<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SN</span>&gt;</span>132487A-J<span class="tag">&lt;/<span class="title">SN</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>crank casing<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">QTY</span>&gt;</span>1<span class="tag">&lt;/<span class="title">QTY</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ORDER</span>&gt;</span></code></pre></div><p>千万不要忘记了保存。即调用<code>XML.Save();</code>。</p>
<p><strong>NOTE:</strong> 这里有一点很囧，就是保存路径无法写<strong>相对路径</strong>。如果有知道如何写入相对路径的，请留言告知，感激不尽。</p>
<h2 id="读取xml">读取XML</h2><p>我们就来读上面写好的<code>Sample.xml</code>吧。如果在同一函数中，完全可以用<a href="http://www.firstobject.com/dn_markGetDoc.htm">GetDoc</a>方法重新读取该文档：</p>
<pre>MCD_STR strXML = xml.GetDoc();

</pre><p><code>Markup.h</code>中定义了<a href="http://www.firstobject.com/dn_markmcdstr.htm">MCD_STR</a>作为默认的字符串类型，你也可以使用<code>std::string</code>或者<code>CString</code>。然后可调用<a href="http://www.firstobject.com/dn_markResetPos.htm">ResetPos</a>方法来返回文档头部。或者咱们重新写个函数，专门来读：</p>
<p><em>再在对话框上新建一个按钮(<code>Read</code>)，并添加<code>BN_CLICKED</code>事件。写下代码：</em></p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtmRead()
{
    <span class="comment">// 读取XML</span>
    CMarkup xml;
    xml.Load(L<span class="string">"F:\\Sample.xml"</span>);
    <span class="comment">//MCD_STR strXML = xml.GetDoc();</span>
    <span class="comment">//xml.SetDoc(strXML);</span>

    xml.FindElem(); <span class="comment">// root ORDER element</span>
    xml.IntoElem(); <span class="comment">// inside ORDER</span>
    CString outPut;
    <span class="keyword">while</span> ( xml.FindElem( L<span class="string">"ITEM"</span>) )
    {
        xml.IntoElem();
        xml.FindElem( L<span class="string">"SN"</span> );
        MCD_STR strSN = xml.GetData();
        xml.FindElem( L<span class="string">"QTY"</span> );
        <span class="keyword">int</span> nQty = _wtoi( MCD_2PCSZ(xml.GetData()) );
        outPut.Format(L<span class="string">"SN:%s\nQTY:%d"</span>,strSN,nQty);
        xml.OutOfElem();
    }

    MessageBox(outPut);
}</code></pre></div><p>首先，需要声明一个<code>CMarkup</code>对象，然后用<a href="http://www.firstobject.com/dn_markLoad.htm">Load</a>方法引入需要解析的XML文档。或者使用<a href="http://www.firstobject.com/dn_markSetDoc.htm">SetDoc</a>方法(见被注释的两行代码)。</p>
<p>然后再循环调用<a href="http://www.firstobject.com/dn_markFindElem.htm">FindElem</a>与<a href="http://www.firstobject.com/dn_markGetData.htm">GetData</a>来定位并获取标签内容。这里如果需要的数字，可以通过<code>atoi</code>来转化字符串，如果在<code>Unicode</code>环境下，需要用<code>_wtoi</code>来转换。<a href="http://www.firstobject.com/dn_markunifiedstlmfc.htm">MCD_2PCSZ</a>在<code>Markup.h</code>中有定义，返回一个字符串的const指针。</p>
<p>最后要注意的就是，每一次定位到某标签，需要调用<a href="http://www.firstobject.com/dn_markIntoElem.htm">IntoElem</a>来进入子标签，并继而通过<a href="http://www.firstobject.com/dn_markOutOfElem.htm">OutOfElem</a>跳出。每一次循环一定由一对<a href="http://www.firstobject.com/dn_markIntoElem.htm">IntoElem</a>和<a href="http://www.firstobject.com/dn_markOutOfElem.htm">OutOfElem</a>来包夹。</p>
<p>运行结果如下：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/ReadXML.png" alt="result"></p>
<h2 id="添加标签及属性">添加标签及属性</h2><p>上面创建的XML仅仅包含一个ITEM标签。下面再举一个例子，通过已有的数据源创建多个ITEM。然后通过<a href="http://www.firstobject.com/dn_markSetAttrib.htm">SetAttrib</a>来为<code>SHIPMENT</code>标签设置一个属性。</p>
<p><em>在对话框上新建一个按钮(<code>Add</code>)，并添加<code>BN_CLICKED</code>事件。写下代码：</em></p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">struct</span> Items
{
    CString strSN;
    CString strName;
    <span class="keyword">int</span> nQty;
};

<span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtnAdd()
{
    <span class="comment">// 向XML中添加标签与属性</span>
    CArray&lt;Items,Items&amp;&gt; aItems;
    Items item1 = {L<span class="string">"132487A-J"</span>,L<span class="string">"crank casing"</span>,<span class="number">1</span>};
    Items item2 = {L<span class="string">"4238764-A"</span>,L<span class="string">"bearing"</span>,<span class="number">15</span>};
    aItems.Add(item1);
    aItems.Add(item2);

    CString strPOCType(L<span class="string">"non-emergency"</span>);
    CString strPOCName(L<span class="string">"John Smith"</span>);
    CString strPOCTel(L<span class="string">"555-1234"</span>);

    CMarkup xml;
    xml.AddElem(L<span class="string">"ORDER"</span>);
    xml.IntoElem(); <span class="comment">// inside ORDER</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> nItem=<span class="number">0</span>; nItem&lt;aItems.GetSize(); ++nItem)
    {
        xml.AddElem( L<span class="string">"ITEM"</span> );
        xml.IntoElem(); <span class="comment">// inside ITEM</span>
        xml.AddElem( L<span class="string">"SN"</span>, aItems[nItem].strSN );
        xml.AddElem( L<span class="string">"NAME"</span>, aItems[nItem].strName );
        xml.AddElem( L<span class="string">"QTY"</span>, aItems[nItem].nQty );
        xml.OutOfElem(); <span class="comment">// back out to ITEM level</span>
    }
    xml.AddElem( L<span class="string">"SHIPMENT"</span> );
    xml.IntoElem(); <span class="comment">// inside SHIPMENT</span>
    xml.AddElem( L<span class="string">"POC"</span> );
    xml.SetAttrib( L<span class="string">"type"</span>, strPOCType );
    xml.IntoElem(); <span class="comment">// inside POC</span>
    xml.AddElem( L<span class="string">"NAME"</span>, strPOCName );
    xml.AddElem( L<span class="string">"TEL"</span>, strPOCTel );

    xml.Save( L<span class="string">"F:\\Sample.xml"</span> );
    MessageBox(L<span class="string">"Success!"</span>);
}</code></pre></div><p>这段代码生成如下XML：根标签<code>ORDER</code>包含了两个<code>ITEM</code>子标签和一个<code>SHIPMENT</code>标签。该<code>ITEM</code>标签包括了<code>SN</code>,<code>NAME</code>和<code>QTY</code>子标签。<code>SHIPMENT</code>标签包含了一个<code>POC</code>子标签，<code>POC</code>拥有一个<code>type</code>属性，和一个<code>NAME</code>、<code>TEL</code>子标签。</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">ORDER</span>&gt;</span>
<span class="tag">&lt;<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SN</span>&gt;</span>132487A-J<span class="tag">&lt;/<span class="title">SN</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>crank casing<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">QTY</span>&gt;</span>1<span class="tag">&lt;/<span class="title">QTY</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SN</span>&gt;</span>4238764-A<span class="tag">&lt;/<span class="title">SN</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>bearing<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">QTY</span>&gt;</span>15<span class="tag">&lt;/<span class="title">QTY</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ITEM</span>&gt;</span>
<span class="tag">&lt;<span class="title">SHIPMENT</span>&gt;</span>
<span class="tag">&lt;<span class="title">POC</span> <span class="attribute">type</span>=<span class="value">"non-emergency"</span>&gt;</span>
<span class="tag">&lt;<span class="title">NAME</span>&gt;</span>John Smith<span class="tag">&lt;/<span class="title">NAME</span>&gt;</span>
<span class="tag">&lt;<span class="title">TEL</span>&gt;</span>555-1234<span class="tag">&lt;/<span class="title">TEL</span>&gt;</span>
<span class="tag">&lt;/<span class="title">POC</span>&gt;</span>
<span class="tag">&lt;/<span class="title">SHIPMENT</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ORDER</span>&gt;</span></code></pre></div><h2 id="查找标签">查找标签</h2><p><code>FindItem</code>方法默认查找<strong>下一个</strong>相邻的标签。如果其参数指定了标签名称，则一直向下查找，直到得到匹配的标签。找到标签的位置将被视为当前位置，下一次调用<code>FindItem</code>方法时，将以当前位置为开端，继续向下查找能够匹配的标签位置。</p>
<p>在FindItem循环查找过程中，如果不想继续顺序查找下去，而是希望返回到第一个标签的位置，可以用<a href="http://www.firstobject.com/dn_markResetMainPos.htm">ResetMainPos</a>。例如上述例子中，如果你无法确定<code>SN</code>标签是否在<code>QTY</code>标签之前(而你恰好又是先找的<code>QTY</code>)，那就可以用<code>ResetMainPos</code>方法返回重新查找。代码如下：</p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">void</span> CtestXmlDlg::OnBnClickedBtnFind()
{
    <span class="comment">// 检索XML</span>
    CMarkup xml;
    xml.Load(L<span class="string">"F:\\Sample.xml"</span>);
    <span class="comment">//MCD_STR strXML = xml.GetDoc();</span>
    <span class="comment">//xml.SetDoc(strXML);</span>

    xml.FindElem(); <span class="comment">// root ORDER element</span>
    xml.IntoElem(); <span class="comment">// inside ORDER</span>

    CString outXml;
    <span class="keyword">while</span> ( xml.FindElem(L<span class="string">"ITEM"</span>) )
    {
        xml.IntoElem();
        xml.FindElem( L<span class="string">"QTY"</span> );
        <span class="keyword">int</span> nQty = _wtoi( MCD_2PCSZ(xml.GetData()) );
        xml.ResetMainPos();
        xml.FindElem( L<span class="string">"SN"</span> );
        MCD_STR strSN = xml.GetData();
        xml.OutOfElem();

        outXml.Format(L<span class="string">"strSN:%s\nnQty:%d"</span>,strSN,nQty);
    }

    CString strFindSN(L<span class="string">"87890310-A"</span>);
    MCD_STR strSN;
    xml.ResetPos(); <span class="comment">// top of document</span>
    xml.FindElem(); <span class="comment">// ORDER element is root</span>
    xml.IntoElem(); <span class="comment">// inside ORDER</span>
    <span class="keyword">while</span> ( xml.FindElem(L<span class="string">"ITEM"</span>) )
    {
        xml.FindChildElem( L<span class="string">"SN"</span> );
        <span class="keyword">if</span> ( xml.GetChildData() == strFindSN )
        {
            strSN = xml.GetChildData();
            <span class="keyword">break</span>; <span class="comment">// found</span>
        }
    }

    xml.Save(L<span class="string">"F:\\Sample.xml"</span>);
    MessageBox(outXml+<span class="string">"\n"</span>+strSN);
}</code></pre></div><p>如果只是想找一个特殊的值(如上述代码中值为&quot;87890310-A&quot;的SN)，可以循环遍历<code>ITEM</code>标签，并比对其子标签<code>SN</code>的值。如果指定查找<code>ITEM</code>标签，如上述代码，那就不会去理其他标签，如<code>SHIPMENT</code>等。</p>
<p>另外，进出<code>ITEM</code>标签去对其子标签<code>SN</code>进行查找，使用<code>FindChildElem</code>和<code>GetChildData</code>方法要便捷的多。</p>
<h2 id="这就完了么？">这就完了么？</h2><p>额，准确的说，上述这点玩意儿，只是最最最基本的操作。不过完全可以看出<code>CMarkup</code>类的便捷简单了吧？利用<code>CMarkup</code>操作XML虽说已经是很成熟的技术了，但它的功能并不是太全面。这只是一种轻量级的工具，合适与否完全看个人需求了。更多的方法API请见<a href="http://www.firstobject.com/dn_markupmethods.htm">这里</a>。</p>
<h2 id="参考资料">参考资料</h2><p>[1] <a href="http://www.firstobject.com/fast-start-to-xml-in-c++.htm">Fast start to XML in C++</a></p>
<p>[2] <a href="http://www.firstobject.com/dn_markupmethods.htm">CMarkup Methods</a></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[关于Unicode编码]]></title>
        <link href="study/unicode-and-ansi"/>
        <published>2012-04-23T00:00:00.000Z</published>
        <updated>2012-04-23T00:00:00.000Z</updated>
        <id>study/unicode-and-ansi</id>
        <content type="html" xml:base="" xml:lang="en">
            <![CDATA[ <p>很多Windows\C++的初学者对于<code>TCHAR</code>, <code>LPCTSTR</code>这些怪异的符号很头疼。(我有一个能力很强的同事便是如此，甚至因为这个丧失了对Windows开发的兴趣，转去做Java了。)今天就把这些玩意一探究竟吧。</p>
<h2 id="简述ansi与unicode">简述ANSI与Unicode</h2><p>显示某个字符，可以用单字节存储，也可以用双字节存储。前者便是我们常见的ANSI编码策略，适用于大多数的英系字符；后者则是Unicode编码策略，几乎可以用以表示世界上所有的文字。</p>
<p>在VC++编译器中，对应于以上两种编码方式，分别给出了<code>char</code>与<code>wchar_t</code>两种数据类型。<em>Unicode</em>还有诸多好处，但现在仅需知道它作为一种双字节存储方式可以更好的支持Windows程序的国际化。</p>
<blockquote>
<p>不止是Unicode，Windows还会用到更多别的双字节编码，如默认使用的UTF-16字符编码。</p>
</blockquote>
<p>作为程序员，一定希望自己的C/C++代码适用于所有的字符编码吧？</p>
<p><strong>建议</strong>：使用通用的数据类型来表示字符与字符串。举个例子吧，请把</p>
<pre>char cResponse; // &#39;Y&#39; or &#39;N&#39;
char sUsername[64];
// str* functions
</pre><p>和
    wchar_t cResponse; // &#39;Y&#39; or &#39;N&#39;
    wchar_t sUsername[64];
    // wcs* functions
替换成：</p>
<pre>#include&lt;TCHAR.H&gt; // Implicit or explicit include
TCHAR cResponse; // &#39;Y&#39; or &#39;N&#39;
TCHAR sUsername[64];
// _tcs* functions

</pre><p>这样就照顾了多语言环境的需求(就像Unicode)，是更加通用的一种形式。</p>
<p>在实际编码的时候，如在VS2010的环境下，可以这样设置编译时所用的字符集：(<em>常规-&gt;字符集</em>)</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/setUnicode.png" alt="setUnicode"></p>
<p>如上图所示，若设置为Unicode，<code>TCHAR</code>将视为<code>wchar_t</code>；若设置为多字节，<code>TCHAR</code>将被视为<code>char</code>。项目的具体设置不会影响到<code>wchar_t</code>或是<code>char</code>类型的使用了。为啥会这样呢，请看<code>TCHAR</code>的定义：</p>
<pre>#ifdef _UNICODE
typedef wchar_t TCHAR;
#else
typedef char TCHAR;
#endif

</pre><p><code>_UNICODE</code>宏的作用就是当项目&quot;<em>设置为Unicode字符集</em>&quot;时，<code>TCHAR</code>含义是<code>wchar_t</code>；&quot;<em>设置为多字节字符集</em>&quot;时，<code>TCHAR</code>含义是<code>char</code>。</p>
<p>与上述类似，为了支持各字符集都能使用最基本的函数，最好使用<code>_tcscpy，_tcslen，_tcscat</code>函数来代替<code>strcpy，strlen，strcat</code>(出于安全的考虑，常会在后面加上<code>_s</code>)或<code>wcscpy,wcslen,wcscat</code>(已经考虑了安全性)。</p>
<p>strlen的原型如下：</p>
<pre>size_t strlen(const char*);

</pre><p>wcslen的原型如下：</p>
<pre>size_t wcslen(const wchar_t* );

</pre><p>最好使用_tcslen，从<em>逻辑</em>上可将其原型表述为：</p>
<pre>size_t _tcslen(const TCHAR* );

</pre><p><strong>wc</strong>表示宽字符，可知<code>wcs</code>表示宽字符串，同理可知<code>_tcs</code>表示_T字符串，能猜到_T在逻辑上既代表<code>char</code>又代表<code>wchar_t</code>了吧？</p>
<p>不过，实际上，<code>_tcslen</code>(还有其他<code>_tcs</code>前缀的函数)并<strong>不是</strong>一个拥有完整定义的真实函数，而仅仅是一个<strong>宏</strong>。其定义应该长这样子：</p>
<pre>#ifdef _UNICODE
#define _tcslen wcslen
#else
#define _tcslen strlen
#endif

</pre><p>在<strong><code>TCHAR.H</code></strong>中，会找到与之相似的准确定义。</p>
<blockquote>
<p>为何定义成宏，而不是直接定义为函数接口呢？</p>
</blockquote>
<p>原因很简单，lib或是dll只能导出单一的函数名与参数类型(这里不考虑C++的重载)。例如，你导出的是：</p>
<pre>void _TPrintChar(char);

</pre><p>而应用程序正好需要用到</p>
<pre>void _TPrintChar(wchar_t);

</pre><p>该怎么办呢？单字节参数不会无缘无故的变成双字节。其实那是两个不同的函数：</p>
<pre>void PrintCharA(char); // A = ANSI
void PrintCharW(wchar_t); // W = Wide character

</pre><p>如果定义一个宏，就轻而易举的解决了这个问题：</p>
<pre>#ifdef _UNICODE
void _TPrintChar(wchar_t);
#else
void _TPrintChar(char);
#endif

</pre><p>届时，应用程序只需如此调用：</p>
<pre>TCHAR cChar;
_TPrintChar(cChar);

</pre><p>宏避免了两种字符集的共存，并允许我们可以运用ANSI或Unicode编码的函数来处理各类字符或字符串。大多数windows函数都采取了这样的措施，为了简化程序员的工作，只写一个函数(用宏去转换)是非常棒的解决方法。<code>SetWindowText</code>便是一个典型的例子：</p>
<pre>// WinUser.H
#ifdef UNICODE
#define SetWindowText  SetWindowTextW
#else
#define SetWindowText  SetWindowTextA
#endif // !UNICODE

</pre><p>极少数的函数没有采用宏，而是仅仅以<strong>W</strong>或<strong>A</strong>后缀作为区分。例如<code>ReadDirectoryChangesW</code>，它并没有ANSI编码的等价函数。</p>
<h2 id="ansi与unicode的转换">ANSI与Unicode的转换</h2><p>我们一般习惯用双引号来标记字符串。其实那是ANSI字符串的用法，其中每个字符均为单字节存储，例如：</p>
<pre>&quot;This is ANSI String. Each letter takes 1 byte&quot;

</pre><p>上述字符串<strong>不支持</strong>Unicode，对多语言环境的支持有限。想要表现为Unicode编码，你需要用到<code>L</code>前缀。例如：</p>
<pre>L&quot;This is Unicode string. Each letter would take 2 bytes, including spaces.&quot;

</pre><p>注意，<strong>L</strong>在字符串的前面，表明这是Unicode字符串。其中<strong>所有</strong>的字符都是双字节存储，包括英文字符、空格、数字、甚至是空字符。因此，Unicode字符串占用的空间将永远是2-字节的倍数。一个长度为7的Unicode字符串需要14字节，诸如此例。所以，永远不存在一个占用15个字节的Unicode字符串。</p>
<p>更通用的说法是，字符串所占空间都是<code>sizeof(TCHAR)</code>个字节的倍数。</p>
<p>当需要表示一个硬编码的字符串时，可以这样：</p>
<pre>&quot;ANSI String&quot;; // ANSI
L&quot;Unicode String&quot;; // Unicode

_T(&quot;Either string, depending on compilation&quot;); // ANSI or Unicode
// or use TEXT macro, if you need more readability

</pre><p>其中，无前缀的是ANSI字符串，<strong>L</strong>前缀的是Unicode字符串，以<code>_T</code>或<code>TEXT</code>标识的，将根据宏定义而定。还是一样，<code>_T</code>和<code>TEXT</code>只是宏而已，它们定义如下：</p>
<pre>// SIMPLIFIED
#ifdef _UNICODE
 #define _T(c) L##c
 #define TEXT(c) L##c
#else
 #define _T(c) c
 #define TEXT(c) c
#endif

</pre><p>这<code>##</code>符号是<a href="http://msdn.microsoft.com/en-us/library/09dwwt6y(v=vs.80).aspx">符号连接操作符</a>，它将<code>_T(&quot;Unicode&quot;)</code>替换为<code>L&quot;Unicode&quot;</code>，该替换取决于宏参数——<code>_UNICODE</code>是否被定义。如果没有被定义，<code>_T(&quot;Unicode&quot;)</code>意味着<code>&quot;Unicode&quot;</code>。<em>符号连接操作符</em>并不仅仅是VC或字符编码中的特定符号，它甚至存在于C语言中。</p>
<p>注意，该宏既适用于字符串，也适用于字符。例如<code>_T(&quot;R&quot;)</code>将被转换为<code>L&quot;R&quot;</code>或<code>&quot;R&quot;</code>。前者为Unicode字符，后者为ANSI字符。</p>
<p><strong>但，这无法转换变量(字符或字符串)</strong>。以下代码就是非法的：</p>
<pre>char c = &#39;C&#39;;
char str[16] = &quot;MyProject&quot;;

_T(c);
_T(str);

</pre><p>最后两句代码可以在ANSI(多字节)下编译成功，因为<code>_T(x)</code>就是<code>x</code>，因此<code>_T(c)</code>和<code>_T(str)</code>将分别输出<code>c</code>和<code>str</code>。但在Unicode字符集下编译，则会报错：</p>
<pre>error C2065: &#39;Lc&#39; : undeclared identifier
error C2065: &#39;Lstr&#39; : undeclared identifier

</pre><p>我们需要注意所有的字符、字符串操作的函数，尤其是windows API提供的那些，基本都是MSDN推荐的典范。拿<code>SetWindowsTextA/W</code>来说吧：</p>
<pre>BOOL SetWindowText(HWND, const TCHAR*);

</pre><p>想必应该知道了，<code>SetWindowText</code>仅仅是一个宏，它取决于你的编译配置，其含义可以是以下其中一个：</p>
<pre>BOOL SetWindowTextA(HWND, const char*);
BOOL SetWindowTextW(HWND, const wchar_t*);

</pre><p>因此，不要困惑于下面这段取地址函数为啥调用失败了！</p>
<pre>HMODULE hDLLHandle;
FARPROC pFuncPtr;
hDLLHandle = LoadLibrary(L&quot;user32.dll&quot;);
pFuncPtr = GetProcAddress(hDLLHandle, &quot;SetWindowText&quot;);
//pFuncPtr will be null, since there doesn&#39;t exist any function with name SetWindowText !

</pre><p><code>SetWindowTextA</code>和<code>SetWindowTextW</code>都由<code>User32.dll</code>所导出的。并没有通用的函数名。</p>
<p>有趣的是，在.Net 框架下总算有了一个通用的函数：</p>
<pre>[DllImport(&quot;user32.dll&quot;)]
extern public static int SetWindowText(IntPtr hWnd, string lpString);

</pre><p>如果没有技术的改进，<code>GetProcAddress</code>怕是还会被一群<em>if..else</em>语句包围吧。</p>
<p>所有的函数都有ANSI和Unicode两个版本，但<strong>实际上却都是由Unicode版本来实现</strong>的。这意味着：当你调用<code>SetWindowTextA</code>时，传入一个ANSI字符串，编译器会先将该字符串转换为Unicode字符串，然后调用<code>SetWindowTextW</code>。类似这样的实际操作(设置窗口的标题、内容及名称等)将都由Unicode版本的函数来执行！</p>
<p>再举一个例子，获取窗口内容将用到<code>GetWindowText</code>。你调用<code>GetWindowTextA</code>时，若目的是得到一个ANSI的buffer。<code>GetWindowTextA</code>将先调用<code>GetWindowTextW</code>，并得到一个Unicode字符串(一个<code>wchar_t</code>数组)。然后为你把Unicode字符串转换为ANSI字符串。</p>
<p>ANSI与Unicode互转的操作并不局限于GUI函数，而涵盖了整个Windows API系列中拥有两套方案的字符串处理函数。例如：</p>
<ul>
<li><code>CreateProcess</code></li>
<li><code>GetUserName</code></li>
<li><code>OpenDesktop</code></li>
<li><code>DeleteFile</code></li>
<li>etc</li>
</ul>
<p>这就是为何都推荐直接使用Unicode版本函数的原因了。不要仅仅因为多年的习惯，而固守ANSI不放，试着用Unicode来编译吧。但，我们可能还是会去存储或读取ANSI字符串，尤其在某些文件操作和消息传递中。这些转换函数还是有其存在的意义的。</p>
<p><strong>注意</strong>：还有一种常见的定义类型：<strong><code>WCHAR</code></strong>，它等价于<code>wchar_t</code>。</p>
<h2 id="更好的指针表示">更好的指针表示</h2><p><code>TCHAR</code>往往修饰单个字符，当然可以声明一个<code>TCHAR</code>的数组。如果你想表示一个<em>character-pointer</em>或一个<em>const-character-pointer</em>，会用下列哪一个呢？</p>
<pre>// ANSI characters
foo_ansi(char*);
foo_ansi(const char*);
/*const*/ char* pString;

// Unicode/wide-string
foo_uni(WCHAR*);
wchar_t* foo_uni(const WCHAR*);
/*const*/ WCHAR* pString;

// Independent
foo_char(TCHAR*);
foo_char(const TCHAR*);
/*const*/ TCHAR* pString;

</pre><p>看过<code>TCHAR</code>的解释，应该会很明确的选择最后一种了吧。那样表示字符串最有效。别忘了引入windows.h头文件。<strong>注意</strong>：如果你的项目直接或间接的引入了windows.h，就不需要引入<code>TCHAR.H</code>了。</p>
<p>首先，再来更好的理解一下老式的字符操作函数，看<code>strlen</code>：</p>
<pre>size_t strlen(const char*);

</pre><p>可以表示为：</p>
<pre>size_t strlen(LPCSTR);

</pre><p><strong><code>LPCSTR</code></strong>符号的定义类型是：</p>
<pre>// Simplified
typedef const char* LPCSTR;

</pre><p>其含义拆解如下：</p>
<ul>
<li><strong>LP</strong> – Long Pointer</li>
<li><strong>C</strong> – Constant</li>
<li><strong>STR</strong> – String</li>
</ul>
<p><code>LPCSTR</code>的本质含义是指向固定字符串的(长)指针。</p>
<p>用新的形式来表述<code>strcpy</code>就是：</p>
<pre>LPSTR strcpy(LPSTR szTarget, LPCSTR szSource);

</pre><p><strong>szTarget</strong>的类型是<code>LPSTR</code>,少了<strong>C</strong>，定义如下：</p>
<pre>typedef char* LPSTR;

</pre><p>注意<strong>szSource</strong>的类型是<code>LPCSTR</code>,<code>strcpy</code>不能改变原字符串，所以要用<code>const</code>限定。返回类型是无const限定的<code>LPSTR</code>。</p>
<p>这些<code>str-</code>函数都是处理ANSI字符串的。但通常我们需要操作双字节字符串，等价的宽字符str函数同样给出了，例如，若计算一个宽字符数组(Unicode字符串)的长度，可以用<strong><code>wcslen</code></strong>：</p>
<pre>size_t nLength;
nLength = wcslen(L&quot;Unicode&quot;);

</pre><p><code>wcslen</code>函数原型：</p>
<pre>size_t wcslen(const wchar_t* szString); // Or WCHAR*

</pre><p>也可以替换为</p>
<pre>size_t wcslen(LPCWSTR szString);

</pre><p>这里的<strong><code>LPCWSTR</code></strong>定义为：</p>
<pre>typedef const WCHAR* LPCWSTR;
// const wchar_t*

</pre><p>拆开来看：</p>
<ul>
<li><strong>LP</strong> - Pointer</li>
<li><strong>C</strong> - Constant</li>
<li><strong>WSTR</strong> - Wide character String</li>
</ul>
<p>类似地，<strong><code>wcscpy</code></strong>与<code>strcpy</code>意义相同，只不过针对的是Unicode字符串：</p>
<pre>wchar_t* wcscpy(wchar_t* szTarget, const wchar_t* szSource)

</pre><p>也可以表现为：</p>
<pre>LPWSTR wcscpy(LPWSTR szTarget, LPCWSTR szSource);

</pre><p>其目标字符串为非常量宽字符串(<code>LPWSTR</code>)，源字符串为常量宽字符串。</p>
<p>存在<code>wcs-</code>函数对应<code>str-</code>函数，前者处理Unicode字符串，后者处理ANSI字符串。</p>
<p>虽然我已经建议过，直接用Unicode的函数替代ANSI与TCHAR的函数。原因很简单，应用程序是必须使用Unicode的，且无须考虑ANSI的兼容性。但出于完整性的考虑，还是继续说明对应的通TCHAR函数吧。</p>
<p>计算字符串长度，可以用<strong><code>_tcslen</code></strong>函数(一个宏)。通常定义如下：</p>
<pre>size_t _tcslen(const TCHAR* szString);
</pre><p>或
    size_t _tcslen(LPCTSTR szString);</p>
<p>这里的<strong><code>LPCTSTR</code></strong>可分解为：</p>
<ul>
<li>LP - Pointer</li>
<li>C - Constant</li>
<li><strong>T = TCHAR</strong></li>
<li>STR = String</li>
</ul>
<p>根据项目设置，<code>LPCTSTR</code>可以映射为<code>LPCSTR</code>(ANSI)或是<code>LPCWSTR</code>(Unicode)。</p>
<p><strong>注意</strong>: <code>strlen</code>, <code>wcslen</code>或<code>_tcslen</code>返回的是<strong>字符</strong>的个数，而不是所占字节数。</p>
<p>仍是拷贝字符串函数，这里为<strong><code>_tcscpy</code></strong>，定义如下：</p>
<pre>size_t _tcscpy(TCHAR* pTarget, const TCHAR* pSource);
</pre><p>或，更加通用的形式：
    size_t _tcscpy(LPTSTR pTarget, LPCTSTR pSource);</p>
<p>可以推断出<strong><code>LPTSTR</code></strong>的含义了吧！</p>
<h2 id="用法举例：">用法举例：</h2><p>首先，看一个代码片段：</p>
<div class="highlight"><pre><code class="cpp"><span class="keyword">int</span> main()
{
    TCHAR name[] = <span class="string">"Saturn"</span>;
    <span class="keyword">int</span> nLen; <span class="comment">// Or size_t</span>

    lLen = strlen(name);
}</code></pre></div><p>在ANSI字符集下编译完美，因为<code>TCHAR</code>转换为<code>char</code>,因此参数<code>name</code>恰好是<code>char</code>字符数组。
如果在Unicode/_UNICODE被定义(或项目设置了Unicode字符集)的情况下，就会报错：</p>
<pre>error C2440: &#39;initializing&#39; : cannot convert from &#39;const char [7]&#39; to &#39;TCHAR []&#39;
error C2664: &#39;strlen&#39; : cannot convert parameter 1 from &#39;TCHAR []&#39; to &#39;const char *&#39;

</pre><p>对于第一个错误，程序员们开始如此修正了：</p>
<pre>TCHAR name[] = (TCHAR*)&quot;Saturn&quot;;

</pre><p>这不可能好使，因为不可能从<code>TCHAR*</code>转换为<code>TCHAR[7]</code>。同样的错误还会出现在，试图将ANSI字符串作为参数传递给Unicode函数：</p>
<pre>nLen = wcslen(&quot;Saturn&quot;);
// ERROR: cannot convert parameter 1 from &#39;const char [7]&#39; to &#39;const wchar_t *&#39;

</pre><p>不幸的是(或谓之幸运？)，错误可以通过下面这般C风格的类型转换而修正：</p>
<pre>nLen = wcslen((const wchar_t*)&quot;Saturn&quot;);

</pre><p>此刻，你会不会觉得在自己对指针的理解又深入了一层？大错特错！这代码将会返回一个错误的结果，并且大多数情况下，会造成访问冲突。这样的套路，就像是本来需要一个80个字节的结构，却传入了一个<code>float</code>变量(从逻辑上而言)。</p>
<p><strong><code>&quot;Saturn&quot;</code></strong>是一个7字节的顺序序列：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43678603/blog_images/stringTable.png" alt="stringTable"></p>
<p>但当你把这一套传递给<code>wcslen</code>时，它会将每两个字节看做一个字符，因此，前两位[97,83]将被当做一个值为24915(<code>97&lt;&lt;8 | 83</code>)的字符，在Unicode里是:<code>？</code>。下一个字符则是[117,116]，以此类推。</p>
<p>你的确没有打算把一串中文字符作为参数，但错误的类型转换却干了这事！因此，要深刻的明白强制转换是<strong>祸根</strong>！正确的做法是将第一行改为：</p>
<pre>TCHAR name[] = _T(&quot;Saturn&quot;);

</pre><p>这样源字符串就会根据编译设置，转换为7字节或是14字节。而<code>wcslen</code>函数应该这样使用：</p>
<pre>wcslen(L&quot;Saturn&quot;);

</pre><p>在上述示例代码中，用的是<code>strlen</code>，那在Unicode环境下无法通过编译。错误的解决方法又来了：</p>
<pre>lLen = strlen ((const char*)name);

</pre><p>在Unicode环境下编译，name将占用14字节(7个Unicode字符，包括null)。因为字符串<strong>&quot;Saturn&quot;</strong>仅包含英文字符，所以用的是原生的ASCII来表现。Unicode字符<code>&#39;S&#39;</code>将表现为[83,0],其他字符也都会接上一个零。注意，现在<code>&#39;S&#39;</code>表现为一个值为83的<strong>双字节</strong>字符，字符串的末端也将表现为一个值为<code>0</code>的<strong>双字节</strong>字符。</p>
<p>所以当把这样的一个字符串传递给<code>strlen</code>时，第一个字符(第一个字节)将是正确的(如&quot;Saturn&quot;中的<code>&#39;S&#39;</code>)。但第二个字符/字节将导致字符串的结束。因此，<code>strlen</code>将返回一个错误的值(<code>1</code>)作为字符串的长度。</p>
<p>Unicode字符串是可以包含非英文字符的，那样的结果就是无法预测的了。</p>
<p>简言之，强制类型转换不总是好使的。或者选择用其本身的类型来正确表示，或者对Unicode与ANSI进行常规的转换。</p>
<h2 id="字符数与字节数">字符数与字节数</h2><p>现在，应该可以理解下面的语句了：</p>
<pre>BOOL SetCurrentDirectory( LPCTSTR lpPathName );
DWORD GetCurrentDirectory(DWORD nBufferLength,LPTSTR lpBuffer);

</pre><p>继续说，你肯定见过某些函数/方法中需要传入<strong>字符数</strong>，或是返回字符数吧。譬如<code>GetCurrentDirectory</code>，你需要传入的是字符数，而<strong>不是</strong>字节数。例如：</p>
<pre>TCHAR sCurrentDir[255];

// Pass 255 and not 255*2
GetCurrentDirectory(sCurrentDir, 255);

</pre><p>而另一方面，如果你需要为数字或字符数组分配空间，则一定要分配整的字节数。在C++中，常使用<code>new</code>关键字：</p>
<pre>LPTSTR pBuffer; // TCHAR*

pBuffer = new TCHAR[128]; // Allocates 128 or 256 BYTES, depending on compilation.

</pre><p>但如果用的是内存分配函数如<code>malloc</code>,<code>LocalAlloc</code>,<code>GlobalAlloc</code>等等，你必须指定其字节数！</p>
<pre>pBuffer = (TCHAR*) malloc (128 * sizeof(TCHAR) );

</pre><p>这里将返回值强制转换是很有必要的，原因自己领悟。<code>malloc</code>语句内的表达式保证分配了其需要的字节数，并为所要求的字符数分配了空间。</p>
<p><strong> <em>这篇文章翻译自<a href="http://www.codeproject.com/Articles/76252/What-are-TCHAR-WCHAR-LPSTR-LPWSTR-LPCTSTR-etc">What are TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR (etc.)?</a>，由于时间仓促以及水平有限，必然存在某些错误，还请高手指正！</em> </strong></p>
]]>
        </content>
    </entry>
</feed>